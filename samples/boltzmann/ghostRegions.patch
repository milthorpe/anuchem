Index: x10.runtime/src-x10/x10/array/ConstantDist.x10
===================================================================
--- x10.runtime/src-x10/x10/array/ConstantDist.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/ConstantDist.x10	(working copy)
@@ -73,55 +73,6 @@
         return onePlace;
     }
     
-    public def offset(pt:Point(rank)):int {
-        if (CompilerFlags.checkPlace() && here!=onePlace) raisePlaceError(pt);
-        val offset = region.indexOf(pt);
-        if (CompilerFlags.checkBounds() && offset == -1) {
-            raiseBoundsError(pt);
-        }
-        return offset;
-    }
-    
-    public def offset(i0:int){rank==1}:int {
-        if (CompilerFlags.checkPlace() && here!=onePlace) raisePlaceError(i0);
-        val offset = region.indexOf(i0);
-        if (CompilerFlags.checkBounds() && offset == -1) {
-            raiseBoundsError(i0);
-        }
-        return offset;
-    }
-    
-    public def offset(i0:int, i1:int){rank==2}:int {
-        if (CompilerFlags.checkPlace() && here!=onePlace) raisePlaceError(i0, i1);
-        val offset = region.indexOf(i0, i1);
-        if (CompilerFlags.checkBounds() && offset == -1) {
-            raiseBoundsError(i0, i1);
-        }
-        return offset;
-    }
-    
-    public def offset(i0:int, i1:int, i2:int){rank==3}:int {
-        if (CompilerFlags.checkPlace() && here!=onePlace) raisePlaceError(i0, i1, i2);
-        val offset = region.indexOf(i0, i1, i2);
-        if (CompilerFlags.checkBounds() && offset == -1) {
-            raiseBoundsError(i0, i1, i2);
-        }
-        return offset;
-    }
-    
-    public def offset(i0:int, i1:int, i2:int, i3:int){rank==4}:int {
-        if (CompilerFlags.checkPlace() && here!=onePlace) raisePlaceError(i0, i1, i2, i3);
-        val offset = region.indexOf(i0, i1, i2, i3);
-        if (CompilerFlags.checkBounds() && offset == -1) {
-            raiseBoundsError(i0, i1, i2, i3);
-        }
-        return offset;
-    }
-    
-    public def maxOffset() {
-        return region.size();
-    }
-    
     public def restriction(r:Region(rank)):Dist(rank) {
         return new WrappedDistRegionRestricted(this, r) as Dist(rank); // TODO: cast should not be needed
     }
Index: x10.runtime/src-x10/x10/array/Array.x10
===================================================================
--- x10.runtime/src-x10/x10/array/Array.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/Array.x10	(working copy)
@@ -166,6 +166,37 @@
 
     /**
      * Construct an Array over the region reg whose
+     * values are initialized as specified by the init function.
+     * The function will be evaluated exactly once for each point
+     * in reg in an arbitrary order to 
+     * compute the initial value for each array element.</p>
+     * 
+     * It is unspecified whether the function evaluations will
+     * be done sequentially for each point by the current activity 
+     * or concurrently for disjoint sets of points by one or more 
+     * child activities. 
+     * 
+     * @param reg The region over which to construct the array.
+     * @param init The function to use to initialize the array.
+     */    
+    public @Inline def this(reg:Region(3){self.rect}, init:(Int,Int,Int)=>T)
+    {
+        property(reg as Region(3){self.rect,self != null}, reg.rank, reg.rect, reg.zeroBased, reg.rail, reg.size());
+        val crh = new LayoutHelper(reg);
+        layout_min0 = crh.min0;
+        layout_stride1 = crh.stride1;
+        layout_min1 = crh.min1;
+        layout = crh.layout;
+        val n = crh.size;
+        val r  = IndexedMemoryChunk.allocateUninitialized[T](n);
+        for ([i,j,k] in reg) {
+            r(offset(i,j,k))= init(i,j,k);
+        }
+        raw = r;
+    }
+
+    /**
+     * Construct an Array over the region reg whose
      * values are initialized to be init.
      * 
      * @param reg The region over which to construct the array.
@@ -818,6 +849,40 @@
         }
         return accum;
     }
+
+    /**
+     * Apply the function <code>map</code> to the elements of this array and
+     * the other src array and reduce the result using the given 
+     * <code>reduce</code> function and the given initial value.
+     * Each element of the array will be given as an argument to the reduction
+     * function exactly once, but in an arbitrary order.  The reduction function
+     * may be applied concurrently to implement a parallel reduction. 
+     * 
+     * @param map the map function
+     * @param reduce the reduce function
+     * @param unit the given initial value for the reduction
+     * @return the final result of the reduction.
+     * @see #map((T,U)=>S)
+     * @see #reduce((U,T)=>U)
+     */
+    public @Inline def mapReduce[S,U,V](src:Array[U](this.rank), map:(T,U)=>S, reduce:(V,S)=>V, unit:V):V {
+        // TODO: once collecting finish is available,
+        //       use it to efficiently parallelize these loops.
+        var accum:V = unit;
+        if (rect) {
+            // In a rect array, every element in the backing raw IndexedMemoryChunk[T]
+            // is included in the array, therefore we can optimize
+            // the traversal and simply map/reduce on the IndexedMemoryChunk itself.
+            for (i in 0..(raw.length()-1)) {
+                accum = reduce(accum, map(raw(i), src.raw(i)));
+            }          
+        } else {
+            for (p in region) {
+                accum = reduce(accum, map(this(p), src(p)));
+            }
+        }
+        return accum;
+    }
     
     /**
      * Scan this array using the function and the given initial value.
@@ -1159,6 +1224,180 @@
         }
         IndexedMemoryChunk.copy(src.raw, srcIndex, dst.raw, dstIndex, numElems);
     }
+
+    /**
+     * Copy the specified region from the source Array to this array.
+     * If the specified region is not contained in the region for the source
+     * array or this array, then an ArrayIndexOutOfBoundsError is raised.
+     * 
+     * @param src the source array.
+     * @param region the region of the array to copy to this array
+     * 
+     * @see Region#indexOf
+     * 
+     * @throws ArrayIndexOutOfBoundsException if the specified region is not
+     *        contained in the source array or this array
+     */
+    public def copy(src:Array[T](this.rank), r:Region(this.rank)) {
+        if (CompilerFlags.checkBounds()) {
+            if ( !src.region.contains(r)) {
+                throw new ArrayIndexOutOfBoundsException("region to copy: " + r + " not contained in source: " + src.region);
+            } else if (!region.contains(r)) {
+                throw new ArrayIndexOutOfBoundsException("region to copy: " + r + " not contained in this array: " + region);
+            }
+        }
+        if (this.rank==3 && r.rect) {
+            (this as Array[T](3)).copy3(src as Array[T](3), r as Region(3){self.rect});
+            return;
+        }
+
+        val srcRaw = src.raw;
+        if (region == src.region) {
+            // fast path - offset in both arrays is the same
+            for (p in r) {
+                val offset = region.indexOf(p);
+                raw(offset) = srcRaw(offset);
+            }
+        } else {
+            // different offset in each array
+            val min = region.min();
+            val max = region.max();
+            val delta = new Array[Int](rank, (i:Int) => region.max(i) - region.min(i) + 1);
+            val srcMin = src.region.min();
+            val srcMax = src.region.max();
+            val srcDelta = new Array[Int](rank, (i:Int) => src.region.max(i) - src.region.min(i) + 1);
+            for (p in r) {
+                var offset:Int = p(0) - min(0);
+                var srcOffset:Int = p(0) - srcMin(0);
+                for (var i:int=1; i<rank; i++) {
+                    offset = offset*delta(i) + p(i) - min(i);
+                    srcOffset = srcOffset*srcDelta(i) + p(i) - srcMin(i);
+                }
+                raw(offset) = srcRaw(srcOffset);
+            }
+        }
+    }
+
+    private def copy3(src:Array[T](3), r:Region(3){self.rect}){this.rank==3} {
+        val srcRaw = src.raw;
+        if (region == src.region) {
+            // fast path - offset in both arrays is the same
+            for ([i,j,k] in r) {
+                val offset = region.indexOf([i,j,k]);
+                raw(offset) = srcRaw(offset);
+            }
+        } else {
+            val layout_stride2 = layout(0);
+            val layout_stride3 = layout(1);
+
+            val crh = new LayoutHelper(src.region);
+            val src_min0 = crh.min0;
+            val src_max0 = src.region.max(0);
+            val src_stride1 = crh.stride1;
+            val src_min1 = crh.min1;
+            val src_max1 = src.region.max(1);
+            val src_layout = crh.layout;
+            val src_stride2 = src_layout(0);
+            val src_stride3 = src_layout(1);
+            val src_min2 = src.region.min(2);
+            val src_max2 = src.region.max(2);
+
+            for (i0 in src_min0..src_max0) {
+                val offset = (i0 - layout_min0) * layout_stride1;
+                val srcOffset = (i0 - src_min0) * src_stride1;
+                for (i1 in src_min1..src_max1) {
+                    val offset1 = (offset + i1 - layout_min1) * layout_stride2;
+                    val srcOffset1 = (srcOffset + i1 - src_min1) * src_stride2;
+                    for (i2 in src_min2..src_max2) {
+                        val offset2 = offset1 + i2 - layout_stride3;
+                        val srcOffset2 = srcOffset1 + i2 - src_stride3;
+                        raw(offset2) = srcRaw(srcOffset2);
+                    }
+                }
+            }
+        }
+    }
+
+
+    /**
+     * Returns the specified region of this array as a new Array object.
+     * 
+     * @param region the region of the array to copy to this array
+     * 
+     * @see Region#indexOf
+     * 
+     * @throws ArrayIndexOutOfBoundsException if the specified region is not
+     *        contained in this array
+     */
+    public def getPatch(r:Region(this.rank){self.rect}):Array[T](this.rank){self.region==r} {
+        if (CompilerFlags.checkBounds() && !region.contains(r)) {
+            throw new ArrayIndexOutOfBoundsException("region to copy: " + r + " not contained in this array: " + region);
+        }
+        if (this.rank==3) return getPatch3(r as Region(3){self.rect});
+
+        val min = region.min();
+        val max = region.max();
+        val delta = new Array[Int](rank, (i:Int) => region.max(i) - region.min(i) + 1);
+        val dstMin = r.min();
+        val dstMax = r.max();
+        val dstDelta = new Array[Int](rank, (i:Int) => r.max(i) - r.min(i) + 1);
+        val dstRaw = IndexedMemoryChunk.allocateUninitialized[T](r.size());
+        for (p in r) {
+            var offset:Int = p(0) - min(0);
+            var dstOffset:Int = p(0) - dstMin(0);
+            for (var i:int=1; i<rank; i++) {
+                offset = offset*delta(i) + p(i) - min(i);
+                dstOffset = dstOffset*dstDelta(i) + p(i) - dstMin(i);
+            }
+            dstRaw(dstOffset) = raw(offset);
+        }
+        return new Array[T](r, dstRaw);
+    }
+
+    /**
+     * Returns the specified region of this array as a new Array object.
+     * 
+     * @param region the region of the array to copy to this array
+     * 
+     * @see Region#indexOf
+     * 
+     * @throws ArrayIndexOutOfBoundsException if the specified region is not
+     *        contained in this array
+     */
+    private def getPatch3(r:Region(3){self.rect}):Array[T](3){self.region==r} {
+        val dstRaw = IndexedMemoryChunk.allocateUninitialized[T](r.size());
+
+        val layout_stride2 = layout(0);
+        val layout_stride3 = layout(1);
+
+        val crh = new LayoutHelper(r);
+        val dst_min0 = crh.min0;
+        val dst_max0 = r.max(0);
+        val dst_stride1 = crh.stride1;
+        val dst_min1 = crh.min1;
+        val dst_max1 = r.max(1);
+        val dst_layout = crh.layout;
+        val dst_stride2 = dst_layout(0);
+        val dst_stride3 = dst_layout(1); 
+        val dst_min2 = r.min(2);
+        val dst_max2 = r.max(2);
+
+        for (i0 in dst_min0..dst_max0) {
+            val offset = (i0 - layout_min0) * layout_stride1;
+            val dstOffset = (i0 - dst_min0) * dst_stride1;
+            for (i1 in dst_min1..dst_max1) {
+                val offset1 = (offset + i1 - layout_min1) * layout_stride2;
+                val dstOffset1 = (dstOffset + i1 - dst_min1) * dst_stride2;
+                for (i2 in dst_min2..dst_max2) {
+                    val offset2 = offset1 + i2 - layout_stride3;
+                    val dstOffset2 = dstOffset1 + i2 - dst_stride3;
+
+                    dstRaw(dstOffset2) = raw(offset2);
+                }
+            }
+        }
+        return new Array[T](r, dstRaw);
+    }
     
     
     private static @NoInline @NoReturn def raiseBoundsError(i0:int) {
Index: x10.runtime/src-x10/x10/array/BlockDistGhostManager.x10
===================================================================
--- x10.runtime/src-x10/x10/array/BlockDistGhostManager.x10	(revision 0)
+++ x10.runtime/src-x10/x10/array/BlockDistGhostManager.x10	(revision 0)
@@ -0,0 +1,149 @@
+/*
+ *  This file is part of the X10 project (http://x10-lang.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  (C) Copyright Australian National University 2011.
+ */
+
+package x10.array;
+
+import x10.util.Team;
+
+/**
+ * A BlockDistGhostManager manages the local ghost region for a DistArray that
+ * is distributed using a BlockDist.
+ */
+final class BlockDistGhostManager extends GhostManager {
+    private val bd:BlockDist;
+    private val leftNeighbor:GhostNeighborFlag;
+    private val rightNeighbor:GhostNeighborFlag;
+    /** 
+     * The Team over bbd.places over which to execute a barrier operation.
+     * TODO this is a workaround for X10_STATIC_THREADS 
+     */
+    private val team:Team;
+    private val periodic:Boolean;
+
+    public def this(ghostWidth:Int, bd:BlockDist, team:Team, periodic:Boolean) {
+        super(ghostWidth);
+        this.bd = bd;
+        this.team = team;
+
+        val pg = bd.places();
+
+        val i = pg.indexOf(here);
+        val left:Place;
+        val right:Place;
+        if (i>0) {
+            left = pg(i-1);
+        } else if (periodic) {
+            left = pg(pg.size()-1);
+        } else {
+            left = here;
+        }
+        this.leftNeighbor = new GhostNeighborFlag(left);
+
+        if (i<(pg.size()-1)) {
+            right = pg(i+1);
+        } else if (periodic) {
+            right = pg(0);
+        } else {
+            right = here;
+        }
+        this.rightNeighbor = new GhostNeighborFlag(right);
+        this.periodic = periodic;
+    }
+
+    /**
+     * @return the halo region of this region, which is the bounding box 
+     * for this region expanded in along bd.axis by <code>ghostWidth</code>
+     */
+    public def getGhostRegion(place:Place):Region {
+        val region = bd(place);
+        if (region.isEmpty()) return region;
+
+        val r = region.boundingBox();
+        val min = new Array[Int](r.rank);
+        val max = new Array[Int](r.rank);
+        for (i in 0..(r.rank-1)) {
+            if (i == bd.axis) {
+                min(i) = r.min(i) - ghostWidth;
+                max(i) = r.max(i) + ghostWidth;
+            } else {
+                min(i) = r.min(i);
+                max(i) = r.max(i);
+            }
+        }
+        return Region.makeRectangular(min, max);
+    }
+    
+    public atomic def setNeighborReceived(place:Place) {
+        if (leftNeighbor.place==place && leftNeighbor.received==false) {
+            leftNeighbor.received = true;
+            //Console.OUT.println("notified leftNeighbor " + place + " at " + here);
+        } else if (rightNeighbor.place==place && rightNeighbor.received==false) {
+            rightNeighbor.received = true;
+            //Console.OUT.println("notified rightNeighbor " + place + " at " + here);
+        } else {
+            throw new BadPlaceException("trying to notify neighbor " + place + " received at " + here + " - not a neighbor!");
+        }
+    }
+
+    public atomic def allNeighborsReceived():Boolean {
+        return leftNeighbor.received && rightNeighbor.received;
+    }
+
+    public atomic def resetNeighborsReceived() {
+        leftNeighbor.received = false;
+        rightNeighbor.received = false;
+    }
+
+    private atomic def setAllNeighborsReceived() {
+        leftNeighbor.received = true;
+        rightNeighbor.received = true;
+    }
+
+    /**
+     * Send ghost data for this place to neighboring places in a BlockDist.
+     * As this DistArray is only divided along one axis, data only need
+     * to be sent along that axis.
+     */
+    public def sendGhosts(array:GhostArray) {
+        prepareToSendGhosts();
+        if (Runtime.STATIC_THREADS) {
+            team.barrier(here.id);
+        }
+        val r = bd(here);
+        if (r.isEmpty()) {
+            setAllNeighborsReceived();
+            return;
+        }
+
+        if (periodic || leftNeighbor.place != here) {
+            val leftMin = new Array[Int](r.rank, (i:Int) => r.min(i));
+            val leftMax = new Array[Int](r.rank, (i:Int) => i==bd.axis ? r.min(i)+ghostWidth-1 : r.max(i));
+            val leftReg = Region.makeRectangular(leftMin, leftMax);
+            val leftNeighborReg = getGhostRegion(leftNeighbor.place) as Region(leftReg.rank){rect};
+            array.sendToNeighbor(leftReg, leftNeighbor.place.id, leftNeighborReg, bd.axis, false, currentPhase(), periodic);
+        } else {
+            leftNeighbor.received = true;
+            //Console.OUT.println("notified leftNeighbor here at " + here);
+        }
+
+        if (periodic || rightNeighbor.place != here) {
+            val rightMin = new Array[Int](r.rank, (i:Int) => i==bd.axis ? r.max(i)-ghostWidth+1 : r.min(i));
+            val rightMax = new Array[Int](r.rank, (i:Int) => r.max(i));
+            val rightReg = Region.makeRectangular(rightMin, rightMax);
+            val rightNeighborReg = getGhostRegion(rightNeighbor.place) as Region(rightReg.rank){rect};
+            array.sendToNeighbor(rightReg, rightNeighbor.place.id, rightNeighborReg, bd.axis, true, currentPhase(), periodic);
+        } else {
+            rightNeighbor.received = true;
+            //Console.OUT.println("notified rightNeighbor here at " + here);
+        }
+    }
+}
+

Property changes on: x10.runtime/src-x10/x10/array/BlockDistGhostManager.x10
___________________________________________________________________
Added: svn:mime-type
   + text/plain
Added: svn:eol-style
   + native

Index: x10.runtime/src-x10/x10/array/GhostManager.x10
===================================================================
--- x10.runtime/src-x10/x10/array/GhostManager.x10	(revision 0)
+++ x10.runtime/src-x10/x10/array/GhostManager.x10	(revision 0)
@@ -0,0 +1,76 @@
+/*
+ *  This file is part of the X10 project (http://x10-lang.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  (C) Copyright Australian National University 2011.
+ */
+
+package x10.array;
+
+/**
+ * A GhostManager manages the ghost region at a single place, including
+ * sending ghost data to other places.
+ * Intended for use in a phased computation: in each phase, ghost data are
+ * updated at all places, then used at all places.
+ * However, synchronization is local between neighboring places, rather than
+ * global between all places.
+ */
+public abstract class GhostManager {
+    /**
+     * The width of the "ghost" region for which each place should
+     * hold a copy of data stored at neighboring places.
+     */
+    public val ghostWidth:Int;
+
+    /**
+     * The current phase of the computation with regard to ghost cell updates.
+     * Places are assumed to progress together; in even phases, ghost cells are
+     * used; in odd phases, ghost cells are updated.  No place may start phase 
+     * P+2 before neighboring places have completed phase P.
+     */
+    protected var currentPhase:Byte;
+
+    public def this(ghostWidth:Int) {
+        this.ghostWidth = ghostWidth;
+        this.currentPhase = 0;
+    }
+
+    public final def currentPhase():Byte {
+        return currentPhase;
+    }
+
+    /** @return the ghost region at the given place */
+    public abstract def getGhostRegion(place:Place):Region;
+    public abstract def setNeighborReceived(place:Place):void;
+    public abstract def allNeighborsReceived():Boolean;
+    public abstract def resetNeighborsReceived():void;
+    public abstract def sendGhosts(array:GhostArray):void;
+
+    /** 
+     * Wait for all ghosts to be received and then return.
+     * Used to switch ghost manager phase from sending to using ghost data.
+     */
+    public def waitOnGhosts() {
+        //Console.OUT.println("waitOnGhosts() - phase " + currentPhase + " at " + here);
+        when (allNeighborsReceived()) {
+            currentPhase++;
+            resetNeighborsReceived();
+        }
+        //Console.OUT.println("waitOnGhosts() - progressed to phase " + currentPhase + " at " + here);
+    }
+
+    /**
+     * Prepare to send ghosts to other places.
+     * Used to switch ghost manager phase from using to sending ghost data.
+     */
+    public atomic def prepareToSendGhosts() {
+        currentPhase++;
+    }
+}
+
+
+

Property changes on: x10.runtime/src-x10/x10/array/GhostManager.x10
___________________________________________________________________
Added: svn:mime-type
   + text/plain
Added: svn:eol-style
   + native

Index: x10.runtime/src-x10/x10/array/PeriodicDist.x10
===================================================================
--- x10.runtime/src-x10/x10/array/PeriodicDist.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/PeriodicDist.x10	(working copy)
@@ -1,246 +0,0 @@
-/*
- *  This file is part of the X10 project (http://x10-lang.org).
- *
- *  This file is licensed to You under the Eclipse Public License (EPL);
- *  You may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *      http://www.opensource.org/licenses/eclipse-1.0.php
- *
- *  (C) Copyright Australian National University 2010-2011.
- */
-
-package x10.array;
-
-import x10.compiler.Inline;
-
-/**
- * A periodic dist decorates a standard X10 dist by implementing 
- * periodic boundary conditions, in which elements at each edge of
- * the region are considered to be neighbours, and indexes that fall
- * outside the "home" region in any dimension are wrapped around modulo 
- * the size of the region in that dimension.
- */
-public final class PeriodicDist extends Dist {
-    val baseDist:Dist{rank==this.rank};
-
-    val min:Array[Int](1); /* will be null if rank<5 */
-    val min0:Int;
-    val min1:Int;
-    val min2:Int;
-    val min3:Int;
-
-    val delta:Array[Int](1); /* will be null if rank<5 */
-    val delta0:Int;
-    val delta1:Int;
-    val delta2:Int;
-    val delta3:Int;
-
-   public def this(base : Dist) : PeriodicDist{self.rank==base.rank} {
-        super(base.region);
-        baseDist = base;
-        val reg = base.region;
-        if (reg.isEmpty()) {
-            min0 = min1 = min2 = min3 = 0;
-            delta0 = delta1 = delta2 = delta3 = 0;
-            if (rank>4) {
-                min = new Array[Int](rank, (Int)=>0);
-                delta = new Array[Int](rank, (Int)=>0);
-            } else {
-                min = delta = null;
-            }
-        } else {
-            if (rank>4) {
-                val tmpMin = new Array[Int](rank, (i:Int) => reg.min(i));
-                min = tmpMin;
-                delta = new Array[Int](rank, (i:Int) => reg.max(i) - tmpMin(i) +1);
-            } else {
-                min = null;
-                delta = null;
-            }
-
-            min0 = reg.min(0);
-            delta0 = reg.max(0) - min0 + 1;
-
-            if (rank > 1) {
-                min1 = reg.min(1);
-                delta1 = reg.max(1) - min1 + 1;
-            } else {
-                min1 = delta1 = 0;
-            }
-
-            if (rank > 2) {
-                min2 = reg.min(2);
-                delta2 = reg.max(2) - min2 + 1;
-            } else {
-                min2 = delta2 = 0;
-            }
-
-            if (rank > 3) {
-                min3 = reg.min(3);
-                delta3 = reg.max(3) - min3 + 1;
-            } else {
-                min3 = delta3 = 0;
-            }
-        }
-    }
-
-    private @Inline def getPeriodicIndex(index : Int, dim : Int) : Int {
-        var regionMin : Int = 0;
-        if (rank < 5) {
-            switch (dim) {
-                case 0:
-                    regionMin = min0;
-                    break;
-                case 1:
-                    regionMin = min1;
-                    break;
-                case 2:
-                    regionMin = min2;
-                    break;
-                case 3:
-                    regionMin = min3;
-                    break;
-                default:
-                    throw new UnsupportedOperationException();
-            }
-        } else {
-            regionMin = min(dim);
-        }
-        var regionDelta : Int = 0;
-        if (rank < 5) {
-            switch (dim) {
-                case 0:
-                    regionDelta = delta0;
-                    break;
-                case 1:
-                    regionDelta = delta1;
-                    break;
-                case 2:
-                    regionDelta = delta2;
-                    break;
-                case 3:
-                    regionDelta = delta3;
-                    break;
-                default:
-                    throw new UnsupportedOperationException();
-            }
-        } else {
-            regionDelta = delta(dim);
-        }
-        var actualIndex : Int = index;
-        while (actualIndex < regionMin) actualIndex += regionDelta;
-        while (actualIndex >= regionMin+regionDelta) actualIndex -= regionDelta;
-        return actualIndex;
-    }
-
-    public @Inline def places():PlaceGroup = baseDist.places();
-    public @Inline def numPlaces():Int = baseDist.numPlaces();
-    public @Inline def regions():Iterable[Region(rank)] = baseDist.regions();
-    public def get(p:Place):Region(rank) = baseDist.get(p);
-
-    // replicated from superclass to workaround xlC bug with using & itables
-    public operator this(p:Place):Region(rank) = get(p);
-
-    public @Inline operator this(pt:Point(rank)):Place {
-        val actualPt = Point.make(rank, (i : Int) => getPeriodicIndex(pt(i), i));
-        return baseDist(actualPt);
-    }
-    public @Inline operator this(i0:Int){rank==1}:Place {
-        var a0 : Int = i0;
-        while (a0 < min0) a0 += delta0;
-        while (a0 >= (min0 + delta0)) a0 -= delta0;
-        return baseDist(a0);
-    }
-    public @Inline operator this(i0:Int, i1:Int){rank==2}:Place {
-        var a0 : Int = i0;
-        while (a0 < min0) a0 += delta0;
-        while (a0 >= (min0 + delta0)) a0 -= delta0;
-        var a1 : Int = i1;
-        while (a1 < min1) a1 += delta1;
-        while (a1 >= (min1 + delta1)) a1 -= delta1;
-        return baseDist(a0, a1);
-    }
-    public @Inline operator this(i0:Int, i1:Int, i2:Int){rank==3}:Place {
-        var a0 : Int = i0;
-        while (a0 < min0) a0 += delta0;
-        while (a0 >= (min0 + delta0)) a0 -= delta0;
-        var a1 : Int = i1;
-        while (a1 < min1) a1 += delta1;
-        while (a1 >= (min1 + delta1)) a1 -= delta1;
-        var a2 : Int = i2;
-        while (a2 < min2) a2 += delta2;
-        while (a2 >= (min2 + delta2)) a2 -= delta2;
-        return baseDist(a0, a1, a2);
-    }
-    public @Inline operator this(i0:Int, i1:Int, i2:Int, i3:Int){rank==4}:Place {
-        var a0 : Int = i0;
-        while (a0 < min0) a0 += delta0;
-        while (a0 >= (min0 + delta0)) a0 -= delta0;
-        var a1 : Int = i1;
-        while (a1 < min1) a1 += delta1;
-        while (a1 >= (min1 + delta1)) a1 -= delta1;
-        var a2 : Int = i2;
-        while (a2 < min2) a2 += delta2;
-        while (a2 >= (min2 + delta2)) a2 -= delta2;
-        var a3 : Int = i3;
-        while (a3 < min3) a3 += delta3;
-        while (a3 >= (min3 + delta3)) a3 -= delta3;
-        return baseDist(a0, a1, a2, a3);
-    }
-
-    public @Inline def offset(pt:Point(rank)):Int {
-        val actualPt = Point.make(rank, (i : Int) => getPeriodicIndex(pt(i), i));
-        return baseDist.offset(actualPt);
-    }
-    public @Inline def offset(i0:Int){rank==1}:Int {
-        var a0 : Int = i0;
-        while (a0 < min0) a0 += delta0;
-        while (a0 >= (min0 + delta0)) a0 -= delta0;
-        return baseDist.offset(a0);
-    }
-    public @Inline def offset(i0:Int, i1:Int){rank==2}:Int {
-        var a0 : Int = i0;
-        while (a0 < min0) a0 += delta0;
-        while (a0 >= (min0 + delta0)) a0 -= delta0;
-        var a1 : Int = i1;
-        while (a1 < min1) a1 += delta1;
-        while (a1 >= (min1 + delta1)) a1 -= delta1;
-        return baseDist.offset(a0, a1);
-    }
-    public @Inline def offset(i0:Int, i1:Int, i2:Int){rank==3}:Int {
-        var a0 : Int = i0;
-        while (a0 < min0) a0 += delta0;
-        while (a0 >= (min0 + delta0)) a0 -= delta0;
-        var a1 : Int = i1;
-        while (a1 < min1) a1 += delta1;
-        while (a1 >= (min1 + delta1)) a1 -= delta1;
-        var a2 : Int = i2;
-        while (a2 < min2) a2 += delta2;
-        while (a2 >= (min2 + delta2)) a2 -= delta2;
-        return baseDist.offset(a0, a1, a2);
-    }
-    public @Inline def offset(i0:Int, i1:Int, i2:Int, i3:Int){rank==4}:Int {
-        var a0 : Int = i0;
-        while (a0 < min0) a0 += delta0;
-        while (a0 >= (min0 + delta0)) a0 -= delta0;
-        var a1 : Int = i1;
-        while (a1 < min1) a1 += delta1;
-        while (a1 >= (min1 + delta1)) a1 -= delta1;
-        var a2 : Int = i2;
-        while (a2 < min2) a2 += delta2;
-        while (a2 >= (min2 + delta2)) a2 -= delta2;
-        var a3 : Int = i3;
-        while (a3 < min3) a3 += delta3;
-        while (a3 >= (min3 + delta3)) a3 -= delta3;
-        return baseDist.offset(a0, a1, a2, a3);
-    }
-
-    public @Inline def maxOffset():Int = baseDist.maxOffset();
-    public @Inline def restriction(r:Region(rank)):Dist(rank) = new PeriodicDist(baseDist.restriction(r));
-    public @Inline def restriction(p:Place):Dist(rank) = new PeriodicDist(baseDist.restriction(p));
-
-    public def toString():String {
-        return "Periodic: " + baseDist.toString();
-    }
-}
-
Index: x10.runtime/src-x10/x10/array/BlockBlockDistGhostManagerPut.x10
===================================================================
--- x10.runtime/src-x10/x10/array/BlockBlockDistGhostManagerPut.x10	(revision 0)
+++ x10.runtime/src-x10/x10/array/BlockBlockDistGhostManagerPut.x10	(revision 0)
@@ -0,0 +1,239 @@
+/*
+ *  This file is part of the X10 project (http://x10-lang.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  (C) Copyright Australian National University 2012.
+ */
+
+package x10.array;
+
+import x10.util.ArrayList;
+import x10.util.Team;
+
+/**
+ * A BlockBlockDistGhostManager manages the local ghost region for a DistArray that
+ * is distributed using a BlockBlockDist.
+ * Ghost regions are sent using a simple put algorithm with no internal synchronization.
+ */
+final class BlockBlockDistGhostManagerPut extends GhostManager {
+    val bbd:BlockBlockDist;
+    val neighbors:Rail[GhostNeighborFlag];
+    /** 
+     * The Team over bbd.places over which to execute a barrier operation.
+     * TODO this is a workaround for X10_STATIC_THREADS 
+     */
+    private val team:Team;
+    private val periodic:Boolean;
+
+    public def this(ghostWidth:Int, bbd:Dist, team:Team, periodic:Boolean) {
+        super(ghostWidth);
+        this.bbd = bbd as BlockBlockDist;
+        this.team = team;
+        this.neighbors = getNeighbors(here, periodic);
+/*
+        var neighborString:String = "neighbors at " + here + ":";
+        for ([p] in neighbors) {
+            neighborString += neighbors(p).place + " ";
+        }
+        Console.OUT.println(neighborString);
+        Console.OUT.flush();
+*/
+        this.periodic = periodic;
+    }
+
+    /** 
+     * Gets neighboring places that hold the blocks immediately surrounding
+     * place p.  In a BlockBlockDist, a place may hold two blocks contiguous
+     * in axis0 ("west-east"), so a place may adjoin either one or two
+     * neighboring places in the "north" and "south" directions.
+     * @param p the place for which to return neighboring places
+     * @param periodic whether the dist is wrapped as a PeriodicDist
+     * @return ghost neighbor flags for the places that hold the blocks surrounding p
+     */
+    public def getNeighbors(p:Place, periodic:Boolean):Rail[GhostNeighborFlag] {
+        val b = bbd.region.boundingBox();
+        val axis0 = bbd.axis0;
+        val axis1 = bbd.axis1;
+        val pg = bbd.places();
+        val min0 = b.min(axis0);
+        val max0 = b.max(axis0);
+        val min1 = b.min(axis1);
+        val max1 = b.max(axis1);
+        val size0 = (max0 - min0 + 1);
+        val size1 = (max1 - min1 + 1);
+        val size0Even = size0 % 2 == 0 ? size0 : size0-1;
+        val P = Math.min(pg.numPlaces(), size0Even * size1);
+        val divisions0 = Math.min(size0Even, Math.pow2(Math.ceil((Math.log(P as Double) / Math.log(2.0)) / 2.0) as Int));
+        val divisions1 = Math.min(size1, Math.ceil((P as Double) / divisions0) as Int);
+        val numBlocks = divisions0 * divisions1;
+        val leftOver = numBlocks - P;
+
+        val i = pg.indexOf(p);
+
+        val leftOverOddOffset = (divisions0 % 2 == 0) ? 0 : i*2/(divisions0+1);
+
+        val blockIndex0 = i < leftOver ? (i*2-leftOverOddOffset) % divisions0 : (i+leftOver) % divisions0;
+        val blockIndex1 = i < leftOver ? (i*2) / divisions0 : (i+leftOver) / divisions0;
+
+        val neighbors = new ArrayList[GhostNeighborFlag]();
+        for (x in -1..1) {
+            for (y in -1..1) {
+                if (x != 0 || y !=0) {
+                    var neighborBlockIndex0:Int = (blockIndex0 + x);
+                    var neighborBlockIndex1:Int = (blockIndex1 + y);
+                    if (i < leftOver && x == 1) {
+                        // this place holds two blocks
+                        neighborBlockIndex0++;
+                    }
+                    val groupIndex = getGroupIndex(neighborBlockIndex0, neighborBlockIndex1, divisions0, divisions1, leftOver, periodic, i);
+        //Console.OUT.println("got neighbor for " + p + " neighborBlockIndex0 = " +  neighborBlockIndex0 + " neighborBlockIndex1 = " + neighborBlockIndex1 + " groupIndex = " + groupIndex);
+
+                    val place = pg(groupIndex);
+                    if (place != here) {
+                    neighbors.add(new GhostNeighborFlag(place));
+                        if (x == 0) {
+                            // there may be two neighbors to the north or south
+                            if (i < leftOver && groupIndex >= leftOver) {
+            //Console.OUT.println("got neighbor for " + p + " neighborBlockIndex0 = " +  neighborBlockIndex0 + " neighborBlockIndex1 = " + neighborBlockIndex1 + " groupIndex = " + (groupIndex+1));
+                                val place2 = pg(groupIndex+1);
+                                if (place2 != place) {
+                                    neighbors.add(new GhostNeighborFlag(place2));
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        return neighbors.toArray();
+    }
+    
+    public atomic def setNeighborReceived(place:Place) {
+        for ([p] in neighbors) {
+            val neighborFlag = neighbors(p);
+            if (neighborFlag.place == place) {
+                neighborFlag.received = true;
+                return;
+            }
+        }
+        throw new BadPlaceException("trying to notify neighbor " + place + " received at " + here + " - not a neighbor!");
+    }
+
+    public atomic def allNeighborsReceived():Boolean {
+        for ([p] in neighbors) {
+            val neighborFlag = neighbors(p);
+            if (neighborFlag.received == false) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public atomic def resetNeighborsReceived() {
+        for ([p] in neighbors) {
+            val neighborFlag = neighbors(p);
+            neighborFlag.received = false;
+        }
+    }
+
+    private atomic def setAllNeighborsReceived() {
+        for ([p] in neighbors) {
+            val neighborFlag = neighbors(p);
+            neighborFlag.received = true;
+        }
+    }
+
+    /**
+     * Send ghost data for this place to neighboring places in a BlockBlockDist 
+     * using Plimpton's shift algorithm. Does not include synchronization.
+     * @see Plimpton, S. (1995) "Fast parallel algorithms for Short-Range 
+     * Molecular Dynamics". J. Comput. Phys. 117-1
+     * @see Palmer, B. and Nieplocha, J. (2002) "Efficient Algorithms for Ghost
+     *  Cell Updates on Two Classes of MPP Architectures". PDCS 2002
+     */
+    public def sendGhosts(array:GhostArray) {
+        prepareToSendGhosts();
+        if (Runtime.STATIC_THREADS) {
+            team.barrier(here.id);
+        }
+        val r = bbd(here);
+        if (r.isEmpty()) {
+            setAllNeighborsReceived();
+            return;
+        }
+
+        for ([p] in neighbors) {
+            val neighborFlag = neighbors(p);
+            val place = neighborFlag.place;
+            if (place != here) {
+                val neighborReg = getGhostRegion(place) as Region(r.rank()){rect};
+                val regionToSend = (r && neighborReg) as Region(r.rank()){rect};
+                //Console.OUT.println("putting " + regionToSend + " from " + here + " to " + place);
+                array.putOverlap(regionToSend, place.id, currentPhase());
+            } else {
+                //Console.OUT.println("setting here received at " + here + " for neighbor " + p);
+                neighborFlag.received = true;
+            }
+        }
+    }
+
+    /**
+     * @return the halo region of this region, which is the bounding box 
+     * for this region expanded in each dimension by <code>ghostWidth</code>
+     */
+    public def getGhostRegion(place:Place):Region {
+        val region = bbd(place);
+        if (region.isEmpty()) return region;
+
+        val r = region.boundingBox();
+        val min = new Array[Int](r.rank);
+        val max = new Array[Int](r.rank);
+        for (i in 0..(r.rank-1)) {
+            if (i == bbd.axis0 || i == bbd.axis1) {
+                min(i) = r.min(i) - ghostWidth;
+                max(i) = r.max(i) + ghostWidth;
+            } else {
+                min(i) = r.min(i);
+                max(i) = r.max(i);
+            }
+        }
+        return Region.makeRectangular(min, max);
+    }
+
+    private static def getGroupIndex(var neighborBlockIndex0:Int, var neighborBlockIndex1:Int, divisions0:Int, divisions1:Int, leftOver:Int, periodic:Boolean, groupIndexHere:Int) {
+        if (periodic) {
+            // wrap around
+            if (neighborBlockIndex0 < 0) {
+                neighborBlockIndex0 += divisions0;
+            } else if (neighborBlockIndex0 >= divisions0) {
+                neighborBlockIndex0 -= divisions0;
+            }
+            if (neighborBlockIndex1 < 0) {
+                neighborBlockIndex1 += divisions1;
+            } else if (neighborBlockIndex1 >= divisions1) {
+                neighborBlockIndex1 -= divisions1;
+            }
+        } else {
+            if (neighborBlockIndex0 < 0 
+             || neighborBlockIndex0 >= divisions0
+             || neighborBlockIndex1 < 0
+             || neighborBlockIndex1 >= divisions1) {
+                // no neighbor in this direction
+                return groupIndexHere;
+            }
+        }
+        val groupIndex:Int;
+        val neighborBlockIndex = (neighborBlockIndex1 * divisions0) + neighborBlockIndex0;
+        if (neighborBlockIndex <= leftOver * 2) {
+            groupIndex = (neighborBlockIndex / 2) as Int;
+        } else {
+            groupIndex = (neighborBlockIndex - leftOver);
+        }
+        return groupIndex;
+    }
+}
+

Property changes on: x10.runtime/src-x10/x10/array/BlockBlockDistGhostManagerPut.x10
___________________________________________________________________
Added: svn:mime-type
   + text/plain
Added: svn:eol-style
   + native

Index: x10.runtime/src-x10/x10/array/Region.x10
===================================================================
--- x10.runtime/src-x10/x10/array/Region.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/Region.x10	(working copy)
@@ -382,7 +382,23 @@
    
     abstract public def eliminate(axis: int): Region /*(rank-1)*/;
 
+    /**
+     * @return the halo region of this region, which is the bounding box 
+     * for this region expanded in each dimension by <code>ghostWidth</code>
+     */
+    public def getHalo(haloWidth:Int):Region(rank) {
+        if (haloWidth == 0 || this.isEmpty()) return this;
+        val r = boundingBox();
+        val min = new Array[Int](rank);
+        val max = new Array[Int](rank);
+        for (i in 0..(rank-1)) {
+            min(i) = r.min(i) - haloWidth;
+            max(i) = r.max(i) + haloWidth;
+        }
+        return Region.makeRectangular(min, max);
+    }
 
+
     /**
      * Return an iterator for this region. Normally accessed using the
      * syntax
Index: x10.runtime/src-x10/x10/array/GhostArray.x10
===================================================================
--- x10.runtime/src-x10/x10/array/GhostArray.x10	(revision 0)
+++ x10.runtime/src-x10/x10/array/GhostArray.x10	(revision 0)
@@ -0,0 +1,23 @@
+/*
+ *  This file is part of the X10 project (http://x10-lang.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  (C) Copyright Australian National University 2011.
+ */
+
+package x10.array;
+
+/**
+ * A GhostArray allows the sending of ghost array data to other places.
+ * This is an interface to DistArray, to avoid the use of generic types
+ * in the interface GhostManager.
+ */
+public interface GhostArray {
+    def getDist():Dist;
+    def sendToNeighbor(r:Region{rect}, neighborId:Int, neighborReg:Region{rank==r.rank,rect}, shiftDim:Int, forward:Boolean, phase:Byte, periodic:Boolean):void;
+    def putOverlap(overlap:Region{rect}, neighborId:Int, phase:Byte):void;
+}

Property changes on: x10.runtime/src-x10/x10/array/GhostArray.x10
___________________________________________________________________
Added: svn:mime-type
   + text/plain
Added: svn:eol-style
   + native

Index: x10.runtime/src-x10/x10/array/BlockBlockDist.x10
===================================================================
--- x10.runtime/src-x10/x10/array/BlockBlockDist.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/BlockBlockDist.x10	(working copy)
@@ -12,6 +12,9 @@
 package x10.array;
 
 import x10.compiler.CompilerFlags;
+import x10.util.ArrayList;
+import x10.util.Pair;
+import x10.util.Team;
 
 /**
  * <p>A BlockBlock distribution maps points in its region
@@ -34,12 +37,12 @@
     /**
      * The first axis along which the region is distributed
      */
-    private val axis0:int;
+    public val axis0:int;
 
     /**
      * The second axis along which the region is distributed
      */
-    private val axis1:int;
+    public val axis1:int;
 
     /**
      * Cached restricted region for the current place.
@@ -235,61 +238,6 @@
         if (CompilerFlags.checkBounds() && !region.contains(pt)) raiseBoundsError(pt);
         return mapIndexToPlace(pt(axis0), pt(axis1));
     }
-
-    public def offset(pt:Point(rank)):int {
-        val r = get(here);
-        val offset = r.indexOf(pt);
-        if (offset == -1) {
-            if (CompilerFlags.checkBounds() && !region.contains(pt)) raiseBoundsError(pt);
-            if (CompilerFlags.checkPlace()) raisePlaceError(pt);
-        }
-        return offset;
-    }
-
-    public def offset(i0:int){rank==1}:int {
-        val r = get(here);
-        val offset = r.indexOf(i0);
-        if (offset == -1) {
-            if (CompilerFlags.checkBounds() && !region.contains(i0)) raiseBoundsError(i0);
-            if (CompilerFlags.checkPlace()) raisePlaceError(i0);
-        }
-        return offset;
-    }
-
-    public def offset(i0:int, i1:int){rank==2}:int {
-        val r = get(here);
-	    val offset = r.indexOf(i0,i1);
-	    if (offset == -1) {
-	        if (CompilerFlags.checkBounds() && !region.contains(i0,i1)) raiseBoundsError(i0,i1);
-            if (CompilerFlags.checkPlace()) raisePlaceError(i0,i1);
-        }
-        return offset;
-    }
-
-    public def offset(i0:int, i1:int, i2:int){rank==3}:int {
-        val r = get(here);
-	    val offset = r.indexOf(i0,i1,i2);
-	    if (offset == -1) {
-	        if (CompilerFlags.checkBounds() && !region.contains(i0,i1,i2)) raiseBoundsError(i0,i1,i2);
-            if (CompilerFlags.checkPlace()) raisePlaceError(i0,i1,i2);
-        }
-        return offset;
-    }
-
-    public def offset(i0:int, i1:int, i2:int, i3:int){rank==4}:int {
-        val r = get(here);
-	    val offset = r.indexOf(i0,i1,i2,i3);
-	    if (offset == -1) {
-	        if (CompilerFlags.checkBounds() && !region.contains(i0,i1,i2,i3)) raiseBoundsError(i0,i1,i2,i3);
-            if (CompilerFlags.checkPlace()) raisePlaceError(i0,i1,i2,i3);
-        }
-        return offset;
-    }
-
-    public def maxOffset() {
-        val r = get(here);
-        return r.size()-1;
-    }
         
     public def restriction(r:Region(rank)):Dist(rank) {
         return new WrappedDistRegionRestricted(this, r) as Dist(rank); // TODO: cast should not be needed
@@ -299,6 +247,9 @@
         return new WrappedDistPlaceRestricted(this, p) as Dist(rank); // TODO: cast should not be needed
     }
 
+    public def getLocalGhostManager(ghostWidth:Int, team:Team, periodic:Boolean) {
+        return new BlockBlockDistGhostManager(ghostWidth, this, team, periodic);
+    }
 
     public def equals(thatObj:Any):boolean {
         if (!(thatObj instanceof BlockBlockDist)) return false;
Index: x10.runtime/src-x10/x10/array/GhostNeighborFlag.x10
===================================================================
--- x10.runtime/src-x10/x10/array/GhostNeighborFlag.x10	(revision 0)
+++ x10.runtime/src-x10/x10/array/GhostNeighborFlag.x10	(revision 0)
@@ -0,0 +1,28 @@
+/*
+ *  This file is part of the X10 project (http://x10-lang.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  (C) Copyright Australian National University 2011.
+ */
+
+package x10.array;
+
+import x10.compiler.Mutable;
+
+/**
+ * A GhostNeighborFlag holds the status of a neighbor place for a GhostManager.
+ * TODO should be mutable struct
+ */
+class GhostNeighborFlag {
+    /** The neighbor place ID.*/
+    public val place:Place;
+    public var received:Boolean;
+    public def this(place:Place) {
+        this.place = place;
+    }
+}
+

Property changes on: x10.runtime/src-x10/x10/array/GhostNeighborFlag.x10
___________________________________________________________________
Added: svn:mime-type
   + text/plain
Added: svn:eol-style
   + native

Index: x10.runtime/src-x10/x10/array/Dist.x10
===================================================================
--- x10.runtime/src-x10/x10/array/Dist.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/Dist.x10	(working copy)
@@ -14,6 +14,8 @@
 import x10.compiler.NoInline;
 import x10.compiler.NoReturn;
 
+import x10.util.Team;
+
 /**
  * A distributution supports distributed arrays by providing a mapping
  * from Points to Places.  Equivalently, a distribution may be defined
@@ -129,10 +131,39 @@
      * @return a "block,block" distribution over r.
      */
     public static def makeBlockBlock(r:Region, axis0:int, axis1:int):Dist(r) {
-        return new BlockBlockDist(r, axis0, axis1, PlaceGroup.WORLD);//) as Dist(r); // TODO: should not need this cast
+        return Dist.makeBlockBlock(r, axis0, axis1, PlaceGroup.WORLD);
     }
 
     /**
+     * Creates a block, block distribution across all places in pg.
+     * The coordinates are split along axis0 into M divisions such that M is the minimum of:
+     *   - 2^q where q is the next integer above log2(P) / 2
+     *   - the length of axis0
+     * and split along axis1 into N divisions such that M*(N-1) <= P <= M*N.
+     * Thus there are M*N blocks of size (axis0/M, axis1/N).
+     * The blocks are not necessarily of integer size in either dimension.
+     * Places 0..(M*N-P) are each assigned two such blocks, contiguous in axis0.
+     * The remaining places are assigned a single block.
+     * Block min and max coordinates are rounded to create subregions for each place,
+     * e.g. a block [1.0..1.5,2.25..2.75] is rounded to a subregion [1..2,2..2].
+     * If there are less than 4 places in pg, a simpler BlockDist is returned.
+     * @param r the given region
+     * @param axis0 the first dimension to block over
+     * @param axis1 the second dimension to block over
+     * @return a "block,block" distribution over r.
+     * @param pg the PlaceGroup over which to distribute the region
+     * @return a "block,block" distribution over r, over the places in pg.
+     */
+    public static def makeBlockBlock(r:Region, axis0:int, axis1:int, pg:PlaceGroup):Dist(r) {
+        if (pg.numPlaces() < 4) {
+            // BlockDist is more efficient
+            return new BlockDist(r, axis0, pg);
+        } else {
+            return new BlockBlockDist(r, axis0, axis1, pg);
+        }
+    }
+
+    /**
      * Create a distribution over the specified region that varies in
      * place only along the 0-th axis. It divides the coordinates
      * along the 0-th axis into Place.MAX_PLACES blocks, and assigns
@@ -340,93 +371,6 @@
     public operator this(i0:int, i1:int, i2:int, i3:int){rank==4}:Place = this(Point.make(i0,i1,i2,i3));
 
 
-
-    /**
-     * Return the offset in linearized place-local storage of the given point.
-     * Throw a BadPlaceException if the given point is not mapped to 
-     * the current place.  Primarily intended to be used by the DistArray implementation,
-     * but may be useful for other data structures as well that need to associate 
-     * Points in a Distribution with a dense, zero-based numbering.
-     *
-     * @param pt the given point
-     * @return the storage offset assigned to pt by this distribution
-     */
-    abstract public def offset(pt:Point(rank)):int;
-
-    /**
-     * Return the offset in linearized place-local storage of the point [i0]
-     * Throw a BadPlaceException if the given point is not mapped to 
-     * the current place.  Primarily intended to be used by the DistArray implementation,
-     * but may be useful for other data structures as well that need to associate 
-     * Points in a Distribution with a dense, zero-based numbering.
-     *
-     * Only applies to one-dimensional distributions.
-     *
-     * @param i0 the given index in the first dimension
-     * @return the storage offset assigned to [i0] by this distribution
-     * @see #offset(Point)
-     */
-    public def offset(i0:int){rank==1}:int = offset(Point.make(i0));
-
-    /**
-     * Return the offset in linearized place-local storage of the point [i0,i1].
-     * Throw a BadPlaceException if the given point is not mapped to 
-     * the current place.  Primarily intended to be used by the DistArray implementation,
-     * but may be useful for other data structures as well that need to associate 
-     * Points in a Distribution with a dense, zero-based numbering.
-     *
-     * Only applies to two-dimensional distributions.
-     *
-     * @param i0 the given index in the first dimension
-     * @param i1 the given index in the second dimension
-     * @return the storage offset assigned to [i0,i1] by this distribution
-     * @see #offset(Point)
-     */
-    public def offset(i0:int, i1:int){rank==2}:int = offset(Point.make(i0, i1));
-
-    /**
-     * Return the offset in linearized place-local storage of the point [i0,i1,i2].
-     * Throw a BadPlaceException if the given point is not mapped to 
-     * the current place.  Primarily intended to be used by the DistArray implementation,
-     * but may be useful for other data structures as well that need to associate 
-     * Points in a Distribution with a dense, zero-based numbering.
-     *
-     * Only applies to three-dimensional distributions.
-     *
-     * @param i0 the given index in the first dimension
-     * @param i1 the given index in the second dimension
-     * @param i2 the given index in the third dimension
-     * @return the storage offset assigned to [i0,i1,i2] by this distribution
-     * @see #offset(Point)
-     */
-    public def offset(i0:int, i1:int, i2:int){rank==3}:int = offset(Point.make(i0, i1, i2));
-
-    /**
-     * Return the offset in linearized place-local storage of the point [i0,i1,i2,i3].
-     * Throw a BadPlaceException if the given point is not mapped to 
-     * the current place.  Primarily intended to be used by the DistArray implementation,
-     * but may be useful for other data structures as well that need to associate 
-     * Points in a Distribution with a dense, zero-based numbering.
-     *
-     * Only applies to four-dimensional distributions.
-     *
-     * @param i0 the given index in the first dimension
-     * @param i1 the given index in the second dimension
-     * @param i2 the given index in the third dimension
-     * @param i3 the given index in the fourth dimension
-     * @return the storage offset assigned to [i0,i1,i2,i3] by this distribution
-     * @see #offset(Point)
-     */
-    public def offset(i0:int, i1:int, i2:int, i3:int){rank==4}:int = offset(Point.make(i0,i1,i2,i3));
-
-    /**
-     * @return the maximum value returned by the offset method for
-     *         the current place for any possible argument Point
-     * @see #offset(Point)
-     */
-    public abstract def maxOffset():int;
-
-
     //
     //
     //
@@ -651,6 +595,17 @@
 */
 
 
+    /** 
+     * @param ghostWidth the width of the ghost region in elements
+     * @param team the Team to use in collective operations 
+        (TODO this is a workaround for X10_STATIC_THREADS)
+     * @param periodic whether periodic boundary conditions apply
+     * @return a ghost manager for this distribution at the current place 
+     */
+    public def getLocalGhostManager(ghostWidth:Int, team:Team, periodic:Boolean):GhostManager {
+        throw new UnsupportedOperationException("" + this.typeName() + ".getLocalGhostManager()");
+    }
+
     public def toString():String {
         var s:String = "Dist(";
         var first:boolean = true;
Index: x10.runtime/src-x10/x10/array/BlockDist.x10
===================================================================
--- x10.runtime/src-x10/x10/array/BlockDist.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/BlockDist.x10	(working copy)
@@ -13,6 +13,8 @@
 
 import x10.compiler.CompilerFlags;
 
+import x10.util.Team;
+
 /**
  * <p>A BlockDist divides the coordinates along one axis
  * of its Region in a block fashion and distributes them
@@ -35,7 +37,7 @@
     /**
      * The axis along which the region is being distributed
      */
-    private val axis:int;
+    public val axis:int;
 
     /**
      * Cached restricted region for the current place.
@@ -113,7 +115,6 @@
         }
     }
     
-    
     public def places():PlaceGroup = pg;
     
     public def numPlaces():int = pg.numPlaces();
@@ -178,62 +179,6 @@
         default: return here; // UNREACHABLE
         }
     }
-
-    public def offset(pt:Point(rank)):int {
-        val r = get(here);
-        val offset = r.indexOf(pt);
-        if (offset == -1) {
-            if (CompilerFlags.checkBounds() && !region.contains(pt)) raiseBoundsError(pt);
-            if (CompilerFlags.checkPlace()) raisePlaceError(pt);
-        }
-        return offset;
-    }
-
-
-    public def offset(i0:int){rank==1}:int {
-        val r = get(here);
-        val offset = r.indexOf(i0);
-        if (offset == -1) {
-            if (CompilerFlags.checkBounds() && !region.contains(i0)) raiseBoundsError(i0);
-            if (CompilerFlags.checkPlace()) raisePlaceError(i0);
-        }
-        return offset;
-    }
-
-    public def offset(i0:int, i1:int){rank==2}:int {
-        val r = get(here);
-        val offset = r.indexOf(i0,i1);
-        if (offset == -1) {
-            if (CompilerFlags.checkBounds() && !region.contains(i0,i1)) raiseBoundsError(i0,i1);
-            if (CompilerFlags.checkPlace()) raisePlaceError(i0,i1);
-        }
-        return offset;
-    }
-
-    public def offset(i0:int, i1:int, i2:int){rank==3}:int {
-        val r = get(here);
-        val offset = r.indexOf(i0,i1,i2);
-        if (offset == -1) {
-            if (CompilerFlags.checkBounds() && !region.contains(i0,i1,i2)) raiseBoundsError(i0,i1,i2);
-            if (CompilerFlags.checkPlace()) raisePlaceError(i0,i1,i2);
-        }
-        return offset;
-    }
-
-    public def offset(i0:int, i1:int, i2:int, i3:int){rank==4}:int {
-        val r = get(here);
-        val offset = r.indexOf(i0,i1,i2,i3);
-        if (offset == -1) {
-            if (CompilerFlags.checkBounds() && !region.contains(i0,i1,i2,i3)) raiseBoundsError(i0,i1,i2,i3);
-            if (CompilerFlags.checkPlace()) raisePlaceError(i0,i1,i2,i3);
-        }
-        return offset;
-    }
-
-    public def maxOffset() {
-        val r = get(here);
-        return r.size()-1;
-    }
         
     public def restriction(r:Region(rank)):Dist(rank) {
         return new WrappedDistRegionRestricted(this, r) as Dist(rank); // TODO: cast should not be needed
@@ -243,6 +188,9 @@
         return new WrappedDistPlaceRestricted(this, p) as Dist(rank); // TODO: cast should not be needed
     }
 
+    public def getLocalGhostManager(ghostWidth:Int, team:Team, periodic:Boolean) {
+        return new BlockDistGhostManager(ghostWidth, this, team, periodic);
+    }
     
     public def equals(thatObj:Any):boolean {
         if (this == thatObj) return true;
Index: x10.runtime/src-x10/x10/array/WrappedDistRegionRestricted.x10
===================================================================
--- x10.runtime/src-x10/x10/array/WrappedDistRegionRestricted.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/WrappedDistRegionRestricted.x10	(working copy)
@@ -62,16 +62,6 @@
     // replicated from superclass to workaround xlC bug with using & itables
     public operator this(i0:int, i1:int, i2:int, i3:int){rank==4}:Place = this(Point.make(i0,i1,i2,i3));
 
-    public def offset(pt:Point(rank)):int {
-        if (filter.contains(pt)) {
-            return base.offset(pt);
-        } else {
-            throw new ArrayIndexOutOfBoundsException("point " + pt + " not contained in distribution");
-        }
-    }
-
-    public def maxOffset():int = base.maxOffset();
-
     public def restriction(r:Region(rank)):Dist(rank) {
         return new WrappedDistRegionRestricted(base, filter.intersection(r)); 
     }
@@ -86,4 +76,4 @@
 	return this.base.equals(that.base) && this.filter.equals(that.filter);
     }
 }
-public type WrappedDistRegionRestricted(r:Int) = WrappedDistRegionRestricted{self.rank==r};
\ No newline at end of file
+public type WrappedDistRegionRestricted(r:Int) = WrappedDistRegionRestricted{self.rank==r};
Index: x10.runtime/src-x10/x10/array/WrappedDistPlaceRestricted.x10
===================================================================
--- x10.runtime/src-x10/x10/array/WrappedDistPlaceRestricted.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/WrappedDistPlaceRestricted.x10	(working copy)
@@ -65,16 +65,6 @@
     // replicated from superclass to workaround xlC bug with using & itables
     public operator this(i0:int, i1:int, i2:int, i3:int){rank==4}:Place = this(Point.make(i0,i1,i2,i3));
 
-    public def offset(pt:Point(rank)):int {
-        if (here == filter) {
-            return base.offset(pt);
-       } else {
-            throw new ArrayIndexOutOfBoundsException("point " + pt + " not contained in distribution");
-        }
-    }
-
-    public def maxOffset():int = base.maxOffset();
-
     public def restriction(r:Region(rank)):Dist(rank) {
         return new WrappedDistRegionRestricted(this, r); 
     }
@@ -93,4 +83,4 @@
 	return this.base.equals(that.base) && this.filter.equals(that.filter);
     }
 }
-public type WrappedDistPlaceRestricted(r:Int)=WrappedDistPlaceRestricted{self.rank==r};
\ No newline at end of file
+public type WrappedDistPlaceRestricted(r:Int)=WrappedDistPlaceRestricted{self.rank==r};
Index: x10.runtime/src-x10/x10/array/BlockBlockDistGhostManager.x10
===================================================================
--- x10.runtime/src-x10/x10/array/BlockBlockDistGhostManager.x10	(revision 0)
+++ x10.runtime/src-x10/x10/array/BlockBlockDistGhostManager.x10	(revision 0)
@@ -0,0 +1,312 @@
+/*
+ *  This file is part of the X10 project (http://x10-lang.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  (C) Copyright Australian National University 2011.
+ */
+
+package x10.array;
+
+import x10.util.ArrayList;
+import x10.util.Team;
+
+/**
+ * A BlockBlockDistGhostManager manages the local ghost region for a DistArray that
+ * is distributed using a BlockBlockDist.
+ */
+final class BlockBlockDistGhostManager extends GhostManager {
+    val bbd:BlockBlockDist;
+    val leftNeighbor:GhostNeighborFlag;
+    val rightNeighbor:GhostNeighborFlag;
+    val topLeftNeighbor:GhostNeighborFlag;
+    val topRightNeighbor:GhostNeighborFlag;
+    val bottomLeftNeighbor:GhostNeighborFlag;
+    val bottomRightNeighbor:GhostNeighborFlag;
+    /** 
+     * The Team over bbd.places over which to execute a barrier operation.
+     * TODO this is a workaround for X10_STATIC_THREADS 
+     */
+    private val team:Team;
+    private val periodic:Boolean;
+
+    public def this(ghostWidth:Int, bbd:BlockBlockDist, team:Team, periodic:Boolean) {
+        super(ghostWidth);
+        this.bbd = bbd;
+        this.team = team;
+
+        val b = bbd.region.boundingBox();
+        val axis0 = bbd.axis0;
+        val axis1 = bbd.axis1;
+        val pg = bbd.places();
+        val min0 = b.min(axis0);
+        val max0 = b.max(axis0);
+        val min1 = b.min(axis1);
+        val max1 = b.max(axis1);
+        val size0 = (max0 - min0 + 1);
+        val size1 = (max1 - min1 + 1);
+        val size0Even = size0 % 2 == 0 ? size0 : size0-1;
+        val P = Math.min(pg.numPlaces(), size0Even * size1);
+        val divisions0 = Math.min(size0Even, Math.pow2(Math.ceil((Math.log(P as Double) / Math.log(2.0)) / 2.0) as Int));
+        val divisions1 = Math.min(size1, Math.ceil((P as Double) / divisions0) as Int);
+                val numBlocks = divisions0 * divisions1;
+        val leftOver = numBlocks - P;
+
+        val i = pg.indexOf(here);
+
+        val leftOverOddOffset = (divisions0 % 2 == 0) ? 0 : i*2/(divisions0+1);
+
+        val blockIndex0 = i < leftOver ? (i*2-leftOverOddOffset) % divisions0 : (i+leftOver) % divisions0;
+        val blockIndex1 = i < leftOver ? (i*2) / divisions0 : (i+leftOver) / divisions0;
+
+        leftNeighbor        = new GhostNeighborFlag(pg(getGroupIndex(blockIndex0-1, blockIndex1, divisions0, divisions1, leftOver, periodic, i)));
+        val topLeft = getGroupIndex(blockIndex0, blockIndex1-1, divisions0, divisions1, leftOver, periodic, i);
+        topLeftNeighbor     = new GhostNeighborFlag(pg(topLeft));
+        val bottomLeft = getGroupIndex(blockIndex0, blockIndex1+1, divisions0, divisions1, leftOver, periodic, i);
+        bottomLeftNeighbor  = new GhostNeighborFlag(pg(bottomLeft));
+        if (i < leftOver) {
+            rightNeighbor       = new GhostNeighborFlag(pg(getGroupIndex(blockIndex0+2, blockIndex1, divisions0, divisions1, leftOver, periodic, i)));
+            if (topLeft >= leftOver) {
+                topRightNeighbor    = new GhostNeighborFlag(pg(getGroupIndex(blockIndex0+1, blockIndex1-1, divisions0, divisions1, leftOver, periodic, i)));
+            } else {
+                topRightNeighbor    = new GhostNeighborFlag(pg(i));
+            }
+            if (bottomLeft >= leftOver) {
+                bottomRightNeighbor = new GhostNeighborFlag(pg(getGroupIndex(blockIndex0+1, blockIndex1+1, divisions0, divisions1, leftOver, periodic, i)));
+            } else {
+                bottomRightNeighbor    = new GhostNeighborFlag(pg(i));
+            }
+        } else {
+            rightNeighbor       = new GhostNeighborFlag(pg(getGroupIndex(blockIndex0+1, blockIndex1, divisions0, divisions1, leftOver, periodic, i)));
+            topRightNeighbor    = new GhostNeighborFlag(pg(i));
+            bottomRightNeighbor = new GhostNeighborFlag(pg(i));
+        }
+        this.periodic = periodic;
+    }
+
+    public def printNeighbors() {
+        Console.OUT.println("at " + here 
+                          + " left = " + leftNeighbor.place 
+                          + " right = " + rightNeighbor.place
+                          + " topLeft = " + topLeftNeighbor.place 
+                          + " topRight = " + topRightNeighbor.place 
+                          + " bottomLeft = " + bottomLeftNeighbor.place 
+                          + " bottomRight = " + bottomRightNeighbor.place);
+    }
+
+    /**
+     * @return the halo region of this region, which is the bounding box 
+     * for this region expanded in each dimension by <code>ghostWidth</code>
+     */
+    public def getGhostRegion(place:Place):Region {
+        val region = bbd(place);
+        if (region.isEmpty()) return region;
+
+        val r = region.boundingBox();
+        val min = new Array[Int](r.rank);
+        val max = new Array[Int](r.rank);
+        for (i in 0..(r.rank-1)) {
+            if (i == bbd.axis0 || i == bbd.axis1) {
+                min(i) = r.min(i) - ghostWidth;
+                max(i) = r.max(i) + ghostWidth;
+            } else {
+                min(i) = r.min(i);
+                max(i) = r.max(i);
+            }
+        }
+        return Region.makeRectangular(min, max);
+    }
+    
+    public atomic def setNeighborReceived(place:Place) {
+        if (topLeftNeighbor.place==place && topLeftNeighbor.received==false) {
+            topLeftNeighbor.received = true;
+            //Console.OUT.println("notified topLeftNeighbor " + place + " at " + here);
+        } else if (topRightNeighbor.place==place && topRightNeighbor.received==false) {
+            topRightNeighbor.received = true;
+            //Console.OUT.println("notified topRightNeighbor " + place + " at " + here);
+        } else if (bottomLeftNeighbor.place==place && bottomLeftNeighbor.received==false) {
+            bottomLeftNeighbor.received = true;
+            //Console.OUT.println("notified bottomLeftNeighbor " + place + " at " + here);
+        } else if (bottomRightNeighbor.place==place && bottomRightNeighbor.received==false) {
+            bottomRightNeighbor.received = true;
+            //Console.OUT.println("notified bottomRightNeighbor " + place + " at " + here);
+        } else if (leftNeighbor.place==place && leftNeighbor.received==false) {
+            leftNeighbor.received = true;
+            //Console.OUT.println("notified leftNeighbor " + place + " at " + here);
+        } else if (rightNeighbor.place==place && rightNeighbor.received==false) {
+            rightNeighbor.received = true;
+            //Console.OUT.println("notified rightNeighbor " + place + " at " + here);
+        } else {
+            throw new BadPlaceException("trying to notify neighbor " + place + " received at " + here + " - not a neighbor!");
+        }
+    }
+
+    public atomic def allNeighborsReceived():Boolean {
+        return leftNeighbor.received
+            && rightNeighbor.received
+            && topLeftNeighbor.received 
+            && topRightNeighbor.received
+            && bottomLeftNeighbor.received
+            && bottomRightNeighbor.received;
+
+    }
+
+    public atomic final def axis1NeighborsReceived():Boolean {
+        return topLeftNeighbor.received 
+            && topRightNeighbor.received
+            && bottomLeftNeighbor.received
+            && bottomRightNeighbor.received;
+    }
+
+    public atomic def resetNeighborsReceived() {
+        leftNeighbor.received = false;
+        rightNeighbor.received = false;
+        topLeftNeighbor.received = false;
+        topRightNeighbor.received = false;
+        bottomLeftNeighbor.received = false;
+        bottomRightNeighbor.received = false;
+    }
+
+    private atomic def setAllNeighborsReceived() {
+        leftNeighbor.received = true;
+        rightNeighbor.received = true;
+        topLeftNeighbor.received = true;
+        topRightNeighbor.received = true;
+        bottomLeftNeighbor.received = true;
+        bottomRightNeighbor.received = true;
+    }
+
+    /**
+     * Send ghost data for this place to neighboring places in a BlockBlockDist 
+     * using Plimpton's shift algorithm. Does not include synchronization.
+     * @see Plimpton, S. (1995) "Fast parallel algorithms for Short-Range 
+     * Molecular Dynamics". J. Comput. Phys. 117-1
+     * @see Palmer, B. and Nieplocha, J. (2002) "Efficient Algorithms for Ghost
+     *  Cell Updates on Two Classes of MPP Architectures". PDCS 2002
+     */
+    public def sendGhosts(array:GhostArray) {
+        prepareToSendGhosts();
+        if (Runtime.STATIC_THREADS) {
+            team.barrier(here.id);
+        }
+        val r = bbd(here);
+        if (r.isEmpty()) {
+            setAllNeighborsReceived();
+            return;
+        }
+
+        // send to neighboring places in one direction along axis1
+        if (periodic || topLeftNeighbor.place != here) {
+            val topMin = new Array[Int](r.rank, (i:Int) => r.min(i));
+            val topMax = new Array[Int](r.rank, (i:Int) => i==bbd.axis1 ? r.min(i)+ghostWidth-1 : r.max(i));
+            val topReg = Region.makeRectangular(topMin, topMax);
+
+            val topLeftNeighborReg = getGhostRegion(topLeftNeighbor.place) as Region(topReg.rank){rect};
+            array.sendToNeighbor(topReg, topLeftNeighbor.place.id, topLeftNeighborReg, bbd.axis1, false, currentPhase(), periodic);
+            if (topRightNeighbor.place != here && topRightNeighbor.place != topLeftNeighbor.place) {
+                //Console.OUT.println("sending to " + topRightNeighbor.place + " from " + here);
+                val topRightNeighborReg = getGhostRegion(topRightNeighbor.place) as Region(topReg.rank){rect};
+                array.sendToNeighbor(topReg, topRightNeighbor.place.id, topRightNeighborReg, bbd.axis1, false, currentPhase(), periodic);
+            } else {
+                topRightNeighbor.received = true;
+                //Console.OUT.println("notified topRightNeighbor here at " + here);
+            }
+        } else {
+            topLeftNeighbor.received = true;
+            topRightNeighbor.received = true;
+            //Console.OUT.println("notified topLeftNeighbor and topRightNeighbor here at " + here);
+        }
+
+
+        // send to neighboring places in the opposite direction along axis1
+        if (periodic || bottomLeftNeighbor.place != here) {
+            val bottomMin = new Array[Int](r.rank, (i:Int) => i==bbd.axis1 ? r.max(i)-ghostWidth+1 : r.min(i));
+            val bottomMax = new Array[Int](r.rank, (i:Int) => r.max(i));
+            val bottomReg = Region.makeRectangular(bottomMin, bottomMax);
+
+            val bottomLeftNeighborReg = getGhostRegion(bottomLeftNeighbor.place) as Region(bottomReg.rank){rect};
+            array.sendToNeighbor(bottomReg, bottomLeftNeighbor.place.id, bottomLeftNeighborReg, bbd.axis1, true, currentPhase(), periodic);
+            if (bottomRightNeighbor.place != here && bottomRightNeighbor.place != bottomLeftNeighbor.place) {
+                //Console.OUT.println("sending to " + bottomRightNeighbor.place + " from " + here);
+                val bottomRightNeighborReg = getGhostRegion(bottomRightNeighbor.place) as Region(bottomReg.rank){rect};
+                array.sendToNeighbor(bottomReg, bottomRightNeighbor.place.id, bottomRightNeighborReg, bbd.axis1, true, currentPhase(), periodic);
+            } else {
+                bottomRightNeighbor.received = true;
+                //Console.OUT.println("notified bottomRightNeighbor here at " + here);
+            }
+        } else {
+            bottomLeftNeighbor.received = true;
+            bottomRightNeighbor.received = true;
+            //Console.OUT.println("notified bottomLeftNeighbor and bottomRightNeighbor here at " + here);
+        }
+
+        // HACK - check for incoming messages for neighbors before blocking wait
+        //Runtime.probe();
+
+        //Console.OUT.println("waiting on axis1 at " + here);
+        when(axis1NeighborsReceived());
+        //Console.OUT.println("progressed on axis1 at " + here);
+
+        // send to neighboring place in one direction along axis0
+        if (periodic || leftNeighbor.place != here) {
+            val leftMin = new Array[Int](r.rank, (i:Int) => i==bbd.axis1 ? r.min(i)-ghostWidth : r.min(i));
+            val leftMax = new Array[Int](r.rank, (i:Int) => i==bbd.axis0 ? r.min(i)+ghostWidth-1 : (i==bbd.axis1 ? r.max(i)+ghostWidth : r.max(i)));
+            val leftReg = Region.makeRectangular(leftMin, leftMax);
+
+            val leftNeighborReg = getGhostRegion(leftNeighbor.place) as Region(leftReg.rank){rect};
+            array.sendToNeighbor(leftReg, leftNeighbor.place.id, leftNeighborReg, bbd.axis0, false, currentPhase(), periodic);
+        } else {
+            leftNeighbor.received = true;
+            //Console.OUT.println("notified leftNeighbor here at " + here);
+        }
+
+        // send to neighboring place in the opposite direction along axis0
+        if (periodic || rightNeighbor.place != here) {
+            val rightMin = new Array[Int](r.rank, (i:Int) => i==bbd.axis0 ? r.max(i)-ghostWidth+1 : (i==bbd.axis1 ? r.min(i)-ghostWidth : r.min(i)));
+            val rightMax = new Array[Int](r.rank, (i:Int) => i==bbd.axis1 ? r.max(i)+ghostWidth : r.max(i));
+            val rightReg = Region.makeRectangular(rightMin, rightMax);
+
+            val rightNeighborReg = getGhostRegion(rightNeighbor.place) as Region(rightReg.rank){rect};
+            array.sendToNeighbor(rightReg, rightNeighbor.place.id, rightNeighborReg, bbd.axis0, true, currentPhase(), periodic);
+        } else {
+            rightNeighbor.received = true;
+            //Console.OUT.println("notified rightNeighbor here at " + here);
+        }
+    }
+
+    private static def getGroupIndex(var neighborBlockIndex0:Int, var neighborBlockIndex1:Int, divisions0:Int, divisions1:Int, leftOver:Int, periodic:Boolean, groupIndexHere:Int) {
+        if (periodic) {
+            // wrap around
+            if (neighborBlockIndex0 < 0) {
+                neighborBlockIndex0 += divisions0;
+            } else if (neighborBlockIndex0 >= divisions0) {
+                neighborBlockIndex0 -= divisions0;
+            }
+            if (neighborBlockIndex1 < 0) {
+                neighborBlockIndex1 += divisions1;
+            } else if (neighborBlockIndex1 >= divisions1) {
+                neighborBlockIndex1 -= divisions1;
+            }
+        } else {
+            if (neighborBlockIndex0 < 0 
+             || neighborBlockIndex0 >= divisions0
+             || neighborBlockIndex1 < 0
+             || neighborBlockIndex1 >= divisions1) {
+                // no neighbor in this direction
+                return groupIndexHere;
+            }
+        }
+        val groupIndex:Int;
+        val neighborBlockIndex = (neighborBlockIndex1 * divisions0) + neighborBlockIndex0;
+        if (neighborBlockIndex <= leftOver * 2) {
+            groupIndex = (neighborBlockIndex / 2) as Int;
+        } else {
+            groupIndex = (neighborBlockIndex - leftOver);
+        }
+        return groupIndex;
+    }
+}
+

Property changes on: x10.runtime/src-x10/x10/array/BlockBlockDistGhostManager.x10
___________________________________________________________________
Added: svn:mime-type
   + text/plain
Added: svn:eol-style
   + native

Index: x10.runtime/src-x10/x10/array/UniqueDist.x10
===================================================================
--- x10.runtime/src-x10/x10/array/UniqueDist.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/UniqueDist.x10	(working copy)
@@ -79,22 +79,6 @@
 
     public operator this(i0:int){rank==1}:Place = pg(i0);
 
-    public def offset(pt:Point(rank)):int {
-        if (CompilerFlags.checkBounds() && !(pt(0) >= 0 && pt(0) < pg.numPlaces())) {
-            raiseBoundsError(pt);
-        }
-        if (CompilerFlags.checkPlace() && pt(0) != pg.indexOf(here)) raisePlaceError(pt);
-        return 0;
-    }
-
-    public def offset(i0:int){rank==1}:int {
-        if (CompilerFlags.checkBounds() && !(i0 >= 0 && i0 < numPlaces())) {
-            raiseBoundsError(i0);
-        }
-        if (CompilerFlags.checkPlace() && i0 != pg.indexOf(here)) raisePlaceError(i0);
-        return 0;
-    }
-
     // replicated from superclass to workaround xlC bug with using & itables
     // This code is completely unreachable
     public operator this(i0:int, i1:int){rank==2}:Place {
@@ -113,8 +97,6 @@
        throw new UnsupportedOperationException("operator(i0:int,i1:int,i2:int,i3:int)");
     }
 
-    public def maxOffset():int = 0;
-
     public def restriction(r:Region(rank)):Dist(rank) {
 	return new WrappedDistRegionRestricted(this, r);// as Dist(rank); // TODO: cast should not be needed
     }
Index: x10.runtime/src-x10/x10/array/PeriodicBoundaryConditions.x10
===================================================================
--- x10.runtime/src-x10/x10/array/PeriodicBoundaryConditions.x10	(revision 0)
+++ x10.runtime/src-x10/x10/array/PeriodicBoundaryConditions.x10	(revision 0)
@@ -0,0 +1,35 @@
+/*
+ *  This file is part of the X10 project (http://x10-lang.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  (C) Copyright Australian National University 2010-2011.
+ */
+
+package x10.array;
+
+import x10.compiler.Inline;
+
+/**
+ * Represents periodic boundary conditions, in which elements at each edge of
+ * a region are considered to be neighbours, and indexes that fall
+ * outside the "home" region in any dimension are wrapped around modulo 
+ * the size of the region in that dimension.
+ */
+public final class PeriodicBoundaryConditions {
+    public static def getPeriodicIndex(index : Int, min:Int, max:Int) : Int {
+        val delta = (max-min+1);
+        var actualIndex : Int = index;
+        while (actualIndex < min) actualIndex += delta;
+        while (actualIndex > max) actualIndex -= delta;
+        return actualIndex;
+    }
+
+    public static def wrapPeriodic(pt:Point, r:Region):Point{self.rank==pt.rank} {
+        return Point.make(pt.rank, (i : Int) => getPeriodicIndex(pt(i), r.min(i), r.max(i)));
+    }
+}
+

Property changes on: x10.runtime/src-x10/x10/array/PeriodicBoundaryConditions.x10
___________________________________________________________________
Added: svn:mime-type
   + text/plain
Added: svn:eol-style
   + native

Index: x10.runtime/src-x10/x10/array/DistArray.x10
===================================================================
--- x10.runtime/src-x10/x10/array/DistArray.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/DistArray.x10	(working copy)
@@ -14,15 +14,18 @@
 import x10.compiler.CompilerFlags;
 import x10.compiler.Header;
 import x10.compiler.Inline;
+import x10.compiler.Mutable;
 import x10.compiler.Native;
 import x10.compiler.NoInline;
 import x10.compiler.NoReturn;
 import x10.compiler.Incomplete;
+import x10.compiler.Uncounted;
 
 import x10.io.CustomSerialization;
 import x10.io.SerialData;
 
 import x10.util.IndexedMemoryChunk;
+import x10.util.Team;
 
 /**
  * <p>A distributed array (DistArray) defines a mapping from {@link Point}s to data 
@@ -53,7 +56,8 @@
     dist:Dist
 ) implements (Point(dist.region.rank))=>T,
              Iterable[Point(dist.region.rank)],
-             CustomSerialization
+             CustomSerialization,
+             GhostArray
 {
 
     //
@@ -70,10 +74,14 @@
      */
     public property rank(): int = dist.rank;
 
-    protected static class LocalState[T](dist:Dist, data:IndexedMemoryChunk[T]) {
-      public def this(d:Dist, c:IndexedMemoryChunk[T]) { 
-          property(d, c);
+    public def getDist() = dist;
 
+    protected static class LocalState[T](dist:Dist, data:IndexedMemoryChunk[T], ghostRegion:Region) {
+      public val ghostManager:GhostManager;
+      public def this(d:Dist, c:IndexedMemoryChunk[T], r:Region, ghostManager:GhostManager) {
+          property(d, c, r);
+          this.ghostManager = ghostManager;
+
           // Calling operator this here serves to force initialization of any 
           // cached local state in the Dist object.  The main reason for doing
           // this is to avoid lazy creation of this state (and thus allocation) 
@@ -82,32 +90,70 @@
       }
     }
 
+    private static def getGhostManager(d:Dist, team:Team, ghostWidth:Int, periodic:Boolean) {
+        if (ghostWidth < 1) return null;
+
+        if (!periodic && d.numPlaces() == 1) return null;
+
+        return d.getLocalGhostManager(ghostWidth, team, periodic);
+    }
+
+    /** @return a team over the places in dist. TODO a workaround for X10_STATIC_THREADS */
+    private def getTeamOverPlaces():Team {
+        val team:Team;
+        val pg = dist.places();
+        if (pg == PlaceGroup.WORLD) {
+            team = Team.WORLD;
+        } else {
+            val places = new Array[Place](pg.size(), (i:Int) => pg(i));
+            team = new Team(places);
+        }
+        return team;
+    }
+
     /** The place-local backing storage for the DistArray */
     protected val localHandle:PlaceLocalHandle[LocalState[T]];
-    /** Can the backing storage be obtained from cachedRaw? */
-    protected transient var cachedRawValid:boolean;
+    /** Have cachedRaw / cachedGhostRegion been set? */
+    protected transient var cachedValid:boolean;
     /** Cached pointer to the backing storage */
     protected transient var cachedRaw:IndexedMemoryChunk[T];
+    /** Cached local ghost region */
+    protected transient var cachedGhostRegion:Region(rank);
+
+    private final @Inline def cacheFields() {
+        cachedRaw = localHandle().data;
+        cachedGhostRegion = localHandle().ghostRegion as Region(rank);
+        x10.util.concurrent.Fences.storeStoreBarrier();
+	    cachedValid = true;
+    }
     
     /**
      * Method to acquire a pointer to the backing storage for the 
      * array's data in the current place.
      */
     protected final def raw():IndexedMemoryChunk[T] {
-        if (!cachedRawValid) {
-            cachedRaw = localHandle().data;
-            x10.util.concurrent.Fences.storeStoreBarrier();
-	    cachedRawValid = true;
+        if (!cachedValid) {
+            cacheFields();
         }
         return cachedRaw;
     }
 
     /**
-     * @return the portion of the DistArray that is stored 
-     *    locally at the current place, as an Array
+     * Method to acquire a pointer to the local region in the current place.
      */
+    public final def localRegion():Region(rank) {
+        if (!cachedValid) {
+            cacheFields();
+        }
+        return cachedGhostRegion;
+    }
+
+    /**
+     * @return the portion of the DistArray (including ghosts) that is stored 
+     *   locally at the current place, as an Array
+     */
     public def getLocalPortion():Array[T](dist.rank) {
-        val regionForHere = dist.get(here);
+        val regionForHere = localRegion();
         if (!regionForHere.rect) throw new UnsupportedOperationException(this.typeName() +".getLocalPortion(): local portion is not rectangular!");
         return new Array[T](regionForHere, raw());
     }
@@ -120,18 +166,78 @@
      */
     public static def make[T](dist:Dist) {T haszero} = new DistArray[T](dist);
 
+    /**
+     * Create a zero-initialized distributed array over the argument distribution
+     * with a BlockBlockDistGhostManagerPut. TODO remove, for testing purposes only
+     */
+    public static def make[T](dist:Dist, ghostWidth:Int, periodic:Boolean, put:Boolean) {T haszero} = new DistArray[T](dist, ghostWidth, periodic, put);
+
+    /**
+     * Create a zero-initialized distributed array over the argument distribution.
+     *
+     * @param dist the given distribution
+     * @param ghostWidth the width of the ghost region in every dimension
+     * @param periodic whether to apply periodic boundary conditions
+     * @return the newly created DistArray
+     */
+    public static def make[T](dist:Dist, ghostWidth:Int, periodic:Boolean) {T haszero} = new DistArray[T](dist, ghostWidth, periodic);
+
+     // TODO: consider making this constructor public
     def this(dist: Dist) {T haszero} : DistArray[T]{self.dist==dist} {
+        this(dist, 0, false);
+    }
+
+    def this(dist: Dist, ghostWidth:Int, periodic:Boolean) {T haszero} : DistArray[T]{self.dist==dist} {
         property(dist);
 
+        val team = getTeamOverPlaces();
         val plsInit:()=>LocalState[T] = () => {
-            val size = dist.places().contains(here) ? dist.maxOffset()+1 : 0;
-            val localRaw = IndexedMemoryChunk.allocateZeroed[T](size);
-            return new LocalState(dist, localRaw);
+            val localRegion:Region(rank);
+            val ghostManager = DistArray.getGhostManager(dist, team, ghostWidth, periodic);
+            if (ghostManager != null) {
+                localRegion = ghostManager.getGhostRegion(here) as Region(rank);
+            } else {
+                localRegion = dist(here);
+            }
+            val localRaw = IndexedMemoryChunk.allocateZeroed[T](localRegion.size());
+            return new LocalState[T](dist, localRaw, localRegion, ghostManager);
         };
 
         localHandle = PlaceLocalHandle.makeFlat[LocalState[T]](PlaceGroup.WORLD, plsInit);
     }
 
+    /**
+     * Creates a DistArray with a BlockBlockDistGhostManagerPut
+     * TODO for testing purposes only
+     */
+    def this(dist: Dist, ghostWidth:Int, periodic:Boolean, put:Boolean) {T haszero} : DistArray[T]{self.dist==dist} {
+        property(dist);
+ 
+        val team = getTeamOverPlaces();
+        val plsInit:()=>LocalState[T] = () => {
+            val localRegion:Region(rank);
+            val ghostManager:GhostManager;
+            if (dist instanceof BlockBlockDist) {
+                ghostManager = new BlockBlockDistGhostManagerPut(ghostWidth, dist as BlockBlockDist, team, periodic);
+            } else {
+                ghostManager = DistArray.getGhostManager(dist, team, ghostWidth, periodic);
+            }
+            if (ghostManager != null) {
+                localRegion = ghostManager.getGhostRegion(here) as Region(rank);
+            } else {
+                localRegion = dist(here);
+            }
+            val localRaw = IndexedMemoryChunk.allocateZeroed[T](localRegion.size());
+
+            return new LocalState[T](dist, localRaw, localRegion, ghostManager);
+        };
+
+        localHandle = PlaceLocalHandle.make[LocalState[T]](dist, plsInit);
+    }
+
+
+
+
     def this(sd:SerialData) {
       val plh:PlaceLocalHandle[LocalState[T]] = sd.data as PlaceLocalHandle[LocalState[T]];
       val d:Dist = plh().dist;
@@ -161,27 +267,50 @@
      * @return the newly created DistArray
      * @see #make[T](Dist)
      */
-    public static def make[T](dist:Dist, init:(Point(dist.rank))=>T)= new DistArray[T](dist, init);
+    public static def make[T](dist:Dist, init:(Point(dist.rank))=>T)= new DistArray[T](dist, init, 0, false);
 
+    /**
+     * Create a distributed array over the argument distribution whose elements
+     * are initialized by executing the given initializer function for each 
+     * element of the array in the place where the argument Point is mapped. 
+     * The function will be evaluated exactly once for each point
+     * in dist in an arbitrary order to compute the initial value for each array element.</p>
+     * 
+     * Within each place, it is unspecified whether the function evaluations will
+     * be done sequentially by a single activity for each point or concurrently for disjoint sets 
+     * of points by one or more child activities. 
+     * 
+     * @param dist the given distribution
+     * @param init the initializer function
+     * @param ghostWidth the width of the ghost region in every dimension
+     * @param periodic whether to apply periodic boundary conditions
+     * @return the newly created DistArray
+     * @see #make[T](Dist)
+     */
+    public static def make[T](dist:Dist, init:(Point(dist.rank))=>T, ghostWidth:Int, periodic:Boolean)= new DistArray[T](dist, init, ghostWidth, periodic);
+
     // TODO: consider making this constructor public
-    def this(dist:Dist, init:(Point(dist.rank))=>T):DistArray[T]{self.dist==dist} {
+    def this(dist:Dist, init:(Point(dist.rank))=>T, ghostWidth:Int, periodic:Boolean):DistArray[T]{self.dist==dist} {
         property(dist);
 
+        val team = getTeamOverPlaces();
         val plsInit:()=>LocalState[T] = () => {
-            val localRaw:IndexedMemoryChunk[T];
-            if (dist.places().contains(here)) {
-                localRaw = IndexedMemoryChunk.allocateUninitialized[T](dist.maxOffset()+1);
-                val reg = dist.get(here);
-                for (pt in reg) {
-                    localRaw(dist.offset(pt)) = init(pt);
-                }
+            val localRegion:Region(rank);
+            val ghostManager = DistArray.getGhostManager(dist, team, ghostWidth, periodic);
+            if (ghostManager != null) {
+                localRegion = ghostManager.getGhostRegion(here) as Region(rank);
             } else {
-                localRaw = IndexedMemoryChunk.allocateUninitialized[T](0);
+                localRegion = dist(here);
             }
-            return new LocalState(dist, localRaw);
+            val localRaw = IndexedMemoryChunk.allocateUninitialized[T](localRegion.size());
+            val reg = dist(here);
+            for (pt in reg) {
+                localRaw(localRegion.indexOf(pt)) = init(pt);
+            }
+            return new LocalState(dist, localRaw, localRegion, ghostManager);
         };
 
-        localHandle = PlaceLocalHandle.make[LocalState[T]](PlaceGroup.WORLD, plsInit);
+        localHandle = PlaceLocalHandle.make[LocalState[T]](dist, plsInit);
     }
 
 
@@ -194,24 +323,41 @@
      * @return the newly created DistArray
      * @see #make[T](Dist)
      */
-    public static def make[T](dist:Dist, init:T)= new DistArray[T](dist, init);
+    public static def make[T](dist:Dist, init:T)= new DistArray[T](dist, init, 0, false);
 
+    /**
+     * Create a distributed array over the argument distribution whose elements
+     * are initialized to the given initial value.
+     *
+     * @param dist the given distribution
+     * @param init the initial value
+     * @param ghostWidth the width of the ghost region in every dimension
+     * @param periodic whether to apply periodic boundary conditions
+     * @return the newly created DistArray
+     * @see #make[T](Dist)
+     */
+    public static def make[T](dist:Dist, init:T, ghostWidth:Int, periodic:Boolean)= new DistArray[T](dist, init, ghostWidth, periodic);
+
+
     // TODO: consider making this constructor public
-    def this(dist:Dist, init:T):DistArray[T]{self.dist==dist} {
+    def this(dist:Dist, init:T, ghostWidth:Int, periodic:Boolean):DistArray[T]{self.dist==dist} {
         property(dist);
 
+        val team = getTeamOverPlaces();
         val plsInit:()=>LocalState[T] = () => {
-            val localRaw:IndexedMemoryChunk[T];
-            if (dist.places().contains(here)) {
-                localRaw = IndexedMemoryChunk.allocateUninitialized[T](dist.maxOffset()+1);
-                val reg = dist.get(here);
-                for (pt in reg) {
-                    localRaw(dist.offset(pt)) = init;
-                }
+            val localRegion:Region(rank);
+            val ghostManager = DistArray.getGhostManager(dist, team, ghostWidth, periodic);
+            if (ghostManager != null) {
+                localRegion = ghostManager.getGhostRegion(here) as Region(rank);
             } else {
-                localRaw = IndexedMemoryChunk.allocateUninitialized[T](0);
+                localRegion = dist(here);
             }
-            return new LocalState(dist, localRaw);
+            val localRaw = IndexedMemoryChunk.allocateUninitialized[T](localRegion.size());
+            val reg = dist(here);
+             for (pt in reg) {
+                localRaw(localRegion.indexOf(pt)) = init;
+             }
+            return new LocalState(dist, localRaw, localRegion, ghostManager);
         };
 
         localHandle = PlaceLocalHandle.makeFlat[LocalState[T]](PlaceGroup.WORLD, plsInit);
@@ -222,14 +368,14 @@
      * as the argument DistArray using a different distribution.</p>
      * 
      * An unchecked invariant for this to be correct is that for every 
-     * point p in d, <code>d.offset(p) == a.dist.offset(p)</code>.  
+     * point p in d, <code>d(here).indexOf(p) == a.dist(here).indexOf(p)</code>.  
      * This invariant is too expensive to be checked dynamically, so it simply must
      * be respected by the DistArray code that calls this constructor.
      */
     protected def this(a:DistArray[T], d:Dist):DistArray[T]{self.dist==d} {
         property(d);
 
-        val plsInit:()=>LocalState[T] = ()=> new LocalState(d, a.localHandle().data);
+        val plsInit:()=>LocalState[T] = ()=> new LocalState(d, a.localHandle().data, a.localHandle().ghostRegion, a.localHandle().ghostManager);
         localHandle = PlaceLocalHandle.makeFlat[LocalState[T]](PlaceGroup.WORLD, plsInit);
     }
 
@@ -256,7 +402,8 @@
      * @see #set(T, Point)
      */
     public final operator this(pt:Point(rank)): T {
-        val offset = dist.offset(pt);
+        val offset = localRegion().indexOf(pt);
+        if (CompilerFlags.checkPlace() && offset == -1) raisePlaceError(pt);
         return raw()(offset);
     }
 
@@ -273,7 +420,8 @@
      * @see #set(T, Int)
      */
     public final operator this(i0:int){rank==1}: T {
-        val offset = dist.offset(i0);
+        val offset = localRegion().indexOf(i0);
+        if (CompilerFlags.checkPlace() && offset == -1) raisePlaceError(i0);
         return raw()(offset);
     }
 
@@ -291,7 +439,8 @@
      * @see #set(T, Int, Int)
      */
     public final operator this(i0:int, i1:int){rank==2}: T {
-        val offset = dist.offset(i0, i1);
+        val offset = localRegion().indexOf(i0, i1);
+        if (CompilerFlags.checkPlace() && offset == -1) raisePlaceError(i0, i1);
         return raw()(offset);
     }
 
@@ -310,7 +459,8 @@
      * @see #set(T, Int, Int, Int)
      */
     public final operator this(i0:int, i1:int, i2:int){rank==3}: T {
-        val offset = dist.offset(i0, i1, i2);
+        val offset = localRegion().indexOf(i0, i1, i2);
+        if (CompilerFlags.checkPlace() && offset == -1) raisePlaceError(i0, i1, i2);
         return raw()(offset);
     }
 
@@ -330,12 +480,66 @@
      * @see #set(T, Int, Int, Int, Int)
      */
     public final operator this(i0:int, i1:int, i2:int, i3:int){rank==4}: T {
-        val offset = dist.offset(i0, i1, i2, i3);
+        val offset = localRegion().indexOf(i0, i1, i2, i3);
+        if (CompilerFlags.checkPlace() && offset == -1) raisePlaceError(i0, i1, i2, i3);
         return raw()(offset);
     }
 
+    /**
+     * Return the element of this array corresponding to the given point,
+     * wrapped for periodic boundary conditions.
+     * The rank of the given point has to be the same as the rank of this array.
+     * If the distribution does not map the given Point to the current place,
+     * then a BadPlaceException will be raised.
+     * 
+     * @param pt the given point
+     * @return the element of this array corresponding to the given point.
+     * @see #operator(Int)
+     * @see #set(T, Point)
+     */
+    public final def getPeriodic(pt:Point(rank)): T {
+        val l = localRegion();
+        val actualPt:Point(rank);
+        if (l.contains(pt)) {
+            actualPt = pt;
+        } else {
+            actualPt = PeriodicBoundaryConditions.wrapPeriodic(pt, region());
+        }
+        val offset = l.indexOf(actualPt);
+        if (CompilerFlags.checkPlace() && offset == -1) raisePlaceError(pt);
+        return raw()(offset);
+    }
 
     /**
+     * Return the element of this three-dimensional array according to the given
+     * indices, wrapped for periodic boundary conditions.
+     * The rank of the given point has to be the same as the rank of this array.
+     * If the distribution does not map the given Point to the current place,
+     * then a BadPlaceException will be raised.
+     * 
+     * @param pt the given point
+     * @return the element of this array corresponding to the given point.
+     * @see #operator(Int)
+     * @see #set(T, Point)
+     */
+    public final def getPeriodic(i0:int, i1:int, i2:int){rank==3}: T {
+        val l = localRegion();
+        val offset:Int;
+        if (l.contains(i0,i1,i2)) {
+            offset = l.indexOf(i0,i1,i2);
+        } else {
+            val r = region();
+            val a0 = PeriodicBoundaryConditions.getPeriodicIndex(i0, r.min(0), r.max(0));
+            val a1 = PeriodicBoundaryConditions.getPeriodicIndex(i1, r.min(1), r.max(1));
+            val a2 = PeriodicBoundaryConditions.getPeriodicIndex(i2, r.min(2), r.max(2));
+            offset = l.indexOf(a0,a1,a2);
+        }
+        if (CompilerFlags.checkPlace() && offset == -1) raisePlaceError(i0, i1, i2);
+        return raw()(offset);
+    }
+
+
+    /**
      * Set the element of this array corresponding to the given point to the given value.
      * Return the new value of the element.
      * The rank of the given point has to be the same as the rank of this array.
@@ -349,7 +553,8 @@
      * @see #set(T, Int)
      */    
     public final operator this(pt: Point(rank))=(v: T): T {
-        val offset = dist.offset(pt);
+        if (CompilerFlags.checkPlace() && dist(pt) != here) raisePlaceError(pt);
+        val offset = localRegion().indexOf(pt);
         raw()(offset) = v;
         return v;
     }
@@ -369,7 +574,8 @@
      * @see #set(T, Point)
      */    
     public final operator this(i0: int)=(v: T){rank==1}: T {
-        val offset = dist.offset(i0);
+        if (CompilerFlags.checkPlace() && dist(i0) != here) raisePlaceError(i0);
+        val offset = localRegion().indexOf(i0);
         raw()(offset) = v;
         return v;
     }
@@ -390,7 +596,8 @@
      * @see #set(T, Point)
      */
     public final operator this(i0: int, i1: int)=(v: T){rank==2}: T {
-        val offset = dist.offset(i0, i1);
+        if (CompilerFlags.checkPlace() && dist(i0, i1) != here) raisePlaceError(i0, i1);
+        val offset = localRegion().indexOf(i0, i1);
         raw()(offset) = v;
         return v;
     }
@@ -412,7 +619,8 @@
      * @see #set(T, Point)
      */
     public final operator this(i0: int, i1: int, i2: int)=(v: T){rank==3}: T {
-        val offset = dist.offset(i0,i1,i2);
+        if (CompilerFlags.checkPlace() && dist(i0, i1, i2) != here) raisePlaceError(i0, i1, i2);
+        val offset = localRegion().indexOf(i0,i1,i2);
         raw()(offset) = v;
         return v;
     }
@@ -435,25 +643,54 @@
      * @see #set(T, Point)
      */
     public final operator this(i0: int, i1: int, i2: int, i3: int)=(v: T){rank==4}: T {
-        val offset = dist.offset(i0,i1,i2,i3);
+        if (CompilerFlags.checkPlace() && dist(i0, i1, i2, i3) != here) raisePlaceError(i0, i1, i2, i3);
+        val offset = localRegion().indexOf(i0,i1,i2,i3);
         raw()(offset) = v;
         return v;
     }
 
+    /**
+     * Set the element of this array corresponding to the given point (wrapped
+     * for periodic boundary conditions) to the given value.
+     * Return the new value of the element.
+     * The rank of the given point has to be the same as the rank of this array.
+     * If the distribution does not map the specified index to the current place,
+     * then a BadPlaceException will be raised.
+     * 
+     * @param v the given value
+     * @param pt the given point
+     * @return the new value of the element of this array corresponding to the given point.
+     * @see #operator(Point)
+     * @see #set(T, Int)
+     */    
+    public final def setPeriodic(pt: Point(rank), v:T): T {
+        val l = localRegion();
+        val actualPt:Point(rank);
+        if (l.contains(pt)) {
+            actualPt = pt;
+        } else {
+            actualPt = PeriodicBoundaryConditions.wrapPeriodic(pt, region());
+        }
+        if (CompilerFlags.checkPlace() && dist(actualPt) != here) raisePlaceError(pt);
+        val offset = l.indexOf(actualPt);
+        raw()(offset) = v;
+        return v;
+    }
+
     /*
      * restriction view
      */
 
     /**
-     * Return a DistArray that access the same backing storage
+     * Return a DistArray that accesses the same backing storage
      * as this array, but only over the Points in the argument
-     * distribtion.</p>
+     * distribution.</p>
      * 
      * For this operation to be semantically sound, it should
      * be the case that for every point p in d, 
-     * <code>this.dist.offset(p) == d.offset</code>.
+     * <code>this.dist(here).indexOf(p) == d(here).indexOf(p)</code>.
      * This invariant is not statically or dynamically checked;
-     * but must be ensured by the caller's of this API. 
+     * but must be ensured by the callers of this API. 
      * 
      * @param d the Dist to use as the restriction
      */
@@ -519,9 +756,10 @@
         finish for (where in dist.places()) {
             at (where) async {
                 val imc = raw();
-                val reg = dist.get(here);
+                val reg = dist(here);
+                val localRegion = localRegion();
                 for (pt in reg) {
-                    imc(dist.offset(pt)) = v;
+                    imc(localRegion.indexOf(pt)) = v;
                 }
             }
         }
@@ -538,19 +776,16 @@
      */
     public final def map[U](op:(T)=>U):DistArray[U](this.dist) {
         val plh = PlaceLocalHandle.make[LocalState[U]](PlaceGroup.WORLD, ()=> {
-            val newImc:IndexedMemoryChunk[U];
-            if (dist.places().contains(here)) {
-                val srcImc = raw();
-                newImc = IndexedMemoryChunk.allocateUninitialized[U](dist.maxOffset()+1);
-                val reg = dist.get(here);
-                for (pt in reg) {
-                    val offset = dist.offset(pt);
-                    newImc(offset) = op(srcImc(offset));
-                }
-            } else {
-                newImc = IndexedMemoryChunk.allocateUninitialized[U](0);
+            val srcImc = raw();
+            val localRegion = localRegion();
+            val newImc = IndexedMemoryChunk.allocateUninitialized[U](localRegion.size());
+            val reg = dist(here);
+            for (pt in reg) {
+                val offset = localRegion.indexOf(pt);
+                newImc(offset) = op(srcImc(offset));
             }
-            return new LocalState[U](dist, newImc);
+            val ghostManager = localHandle().ghostManager;
+            return new LocalState[U](dist, newImc, localRegion, ghostManager);
         });
         return new DistArray[U](dist, plh);                       
     }
@@ -569,11 +804,12 @@
         finish {
             for (where in dist.places()) {
                 at(where) async {
-                    val reg = dist.get(here);
+                    val reg = dist(here);
+                    val localRegion = localRegion();
                     val srcImc = raw();
                     val dstImc = dst.raw();
                     for (pt in reg) {
-                        val offset = dist.offset(pt);
+                        val offset = localRegion.indexOf(pt);
                         dstImc(offset) = op(srcImc(offset));
                     }
                 }
@@ -598,12 +834,13 @@
         finish {
             for (where in dist.places()) {
                 at(where) async {
-                    val reg = dist.get(here);
+                    val reg = dist(here);
                     val freg = reg && filter;
+                    val localRegion = localRegion();
                     val srcImc = raw();
                     val dstImc = dst.raw();
                     for (pt in freg) {
-                        val offset = dist.offset(pt);
+                        val offset = localRegion.indexOf(pt);
                         dstImc(offset) = op(srcImc(offset));
                     }
                 }
@@ -624,20 +861,17 @@
      */
     public final def map[S,U](src:DistArray[U](this.dist), op:(T,U)=>S):DistArray[S](dist) {
         val plh = PlaceLocalHandle.make[LocalState[S]](PlaceGroup.WORLD, ()=> {
-            val newImc:IndexedMemoryChunk[S];
-            if (dist.places().contains(here)) {
-                val src1Imc = raw();
-                val src2Imc = src.raw();
-                newImc = IndexedMemoryChunk.allocateUninitialized[S](dist.maxOffset()+1);
-                val reg = dist.get(here);
-                for (pt in reg) {
-                    val offset = dist.offset(pt);
-                    newImc(offset) = op(src1Imc(offset), src2Imc(offset));
-                }
-            } else {
-                newImc = IndexedMemoryChunk.allocateUninitialized[S](0);
+            val src1Imc = raw();
+            val src2Imc = src.raw();
+            val reg = dist.get(here);
+            val localRegion = localRegion();
+            val newImc = IndexedMemoryChunk.allocateUninitialized[S](localRegion.size());
+            for (pt in reg) {
+                val offset = localRegion.indexOf(pt);
+                newImc(offset) = op(src1Imc(offset), src2Imc(offset));
             }
-            return new LocalState[S](dist, newImc);
+            val ghostManager = localHandle().ghostManager;
+            return new LocalState[S](dist, newImc, localRegion, ghostManager);
         });
         return new DistArray[S](dist, plh);                       
     }
@@ -657,12 +891,13 @@
         finish {
             for (where in dist.places()) {
                 at(where) async {
-                    val reg = dist.get(here);
+                    val reg = dist(here);
+                    val localRegion = localRegion();
                     val src1Imc = raw();
                     val src2Imc = src.raw();
                     val dstImc = dst.raw();
                     for (pt in reg) {
-                        val offset = dist.offset(pt);
+                        val offset = localRegion.indexOf(pt);
                         dstImc(offset) = op(src1Imc(offset), src2Imc(offset));
                     }
                 }
@@ -687,13 +922,14 @@
         finish {
             for (where in dist.places()) {
                 at(where) async {
-                    val reg = dist.get(here);
+                    val reg = dist(here);
+                    val localRegion = localRegion();
                     val freg = reg && filter;
                     val src1Imc = raw();
                     val src2Imc = src.raw();
                     val dstImc = dst.raw();
                     for (pt in freg) {
-                        val offset = dist.offset(pt);
+                        val offset = localRegion.indexOf(pt);
                         dstImc(offset) = op(src1Imc(offset), src2Imc(offset));
                     }
                 }
@@ -737,11 +973,12 @@
         val result = finish(reducer) {
             for (where in dist.places()) {
                 at (where) async {
-                    val reg = dist.get(here);
+                    val reg = dist(here);
+                    val localRegion = localRegion();
                     var localRes:U = unit;
                     val imc = raw();
                     for (pt in reg) {
-                       localRes = lop(localRes, imc(dist.offset(pt)));
+                       localRes = lop(localRes, imc(localRegion.indexOf(pt)));
                     }
                     offer(localRes);
                 }
@@ -751,7 +988,222 @@
         return result;
     }
 
+    /**
+     * Updates ghost data for every place in this DistArray.
+     * This includes synchronization before and after the update.
+     */
+    public def updateGhosts() {
+        if (localHandle().ghostManager != null) {
+            finish ateach(place in Dist.makeUnique(dist.places())) {
+                val ghostManager = localHandle().ghostManager;
+                ghostManager.sendGhosts(this);
+                ghostManager.waitOnGhosts();
+            }
+        }
+    }
 
+    public def sendGhosts() {
+        val ghostManager = localHandle().ghostManager;
+        if (ghostManager != null) {
+            ghostManager.sendGhosts(this);
+        }
+    }
+
+    public def waitOnGhosts() {
+        val ghostManager = localHandle().ghostManager;
+        if (ghostManager != null) {
+            ghostManager.waitOnGhosts();
+        }
+    }
+
+    /**
+     * Sends one edge of ghost data to neighboring places in
+     * the direction of <code>shift</code>.
+     * @param reg the region of data held at this place that should be sent to neighboring places
+     * @param shiftDim the dimension along which the data should be sent
+     * @param forward whether to send in the forward or backwards direction
+     * @param notify whether to set the [...]GhostReceived flags to notify at the destination place
+     */
+    public def sendToNeighbor(r:Region{rect}, neighborId:Int, neighborReg:Region{rank==r.rank,rect}, shiftDim:Int, forward:Boolean, phase:Byte, periodic:Boolean):void {
+        val neighbor = Place(neighborId);
+        if (rank==3) {
+            sendToNeighbor3(r as Region(3){rect}, neighbor, neighborReg as Region(3){rect}, shiftDim, forward, phase, periodic);
+        } else {
+            val reg = r as Region(rank){rect};
+            var neighborSent:Boolean = false;
+            val sourcePlace = here;
+            if (neighbor != here) {
+                val g = localRegion();
+                val localRaw = raw();
+                val overlap = (neighborReg && reg) as Region(rank){rect};
+                if (! overlap.isEmpty()) {
+                    neighborSent = true;
+                    val neighborPortion = new Array[T](overlap, (p:Point(rank)) => localRaw(g.indexOf(p)) );
+                    @Uncounted at(neighbor) async {
+                        val ghostManager = localHandle().ghostManager;
+                        if (!Runtime.STATIC_THREADS) {
+                            //Console.OUT.println("waiting at " + here + " to deliver ghosts from " + sourcePlace);
+                            when (ghostManager.currentPhase() == phase);
+                        }
+                        val local2 = getLocalPortion();
+                        val local2Reg = local2.region;
+                        val local2Raw = local2.raw();
+                        for (p in overlap) {
+                            local2Raw(local2Reg.indexOf(p)) = neighborPortion(p);
+                        }
+                        ghostManager.setNeighborReceived(sourcePlace);
+                        //Console.OUT.println("setNeighborReceived at " + here + " from " + sourcePlace);
+                    }
+                }
+            }
+            if (!neighborSent && periodic) {
+                // there may still be a 'neighbor' with PBC
+                val g = localRegion();
+                val localRaw = raw();
+                val wrap = (region.max(shiftDim)-region.min(shiftDim)+1);
+                val wrapShift = Point.make(rank, (i:Int) => i==shiftDim ? (forward?-wrap:wrap) : 0);
+                val wrapReg = reg + wrapShift;
+                val overlap = (neighborReg && wrapReg) as Region(rank){rect};
+                if (! overlap.isEmpty()) {
+                    neighborSent = true;
+                    val wrapOverlap = (overlap - wrapShift) as Region(rank){rect};
+                    val neighborPortion = new Array[T](wrapOverlap, (p:Point(rank)) => localRaw(g.indexOf(p)) );
+                    @Uncounted at(neighbor) async {
+                        val ghostManager = localHandle().ghostManager;
+                        if (!Runtime.STATIC_THREADS) {
+                            //Console.OUT.println("waiting at " + here + " to deliver ghosts from " + sourcePlace + " phase " + phase + " periodic");
+                            when (ghostManager.currentPhase() == phase);
+                        }
+                        val local2 = getLocalPortion();
+                        val local2Reg = local2.region;
+                        val local2Raw = local2.raw();
+                        for (p in overlap) {
+                            val offset = local2Reg.indexOf(p);
+                            local2Raw(offset) = neighborPortion(p - wrapShift);
+                        }
+                        ghostManager.setNeighborReceived(sourcePlace);
+                        //Console.OUT.println("setNeighborReceived at " + here + " from " + sourcePlace + " phase " + phase + " periodic");
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Sends one edge of ghost data to neighboring places in
+     * the direction of <code>shift</code> for a rank-3 region.
+     * This is a hack to demonstrate the performance that would be possible with inlined Points.
+     * @param reg the region of data held at this place that should be sent to neighboring places
+     * @param shiftDim the dimension along which the data should be sent
+     * @param forward whether to send in the forward or backwards direction
+     * @param notify whether to set the [...]GhostReceived flags to notify at the destination place
+     */
+    private final def sendToNeighbor3(reg:Region(3){rect}, neighbor:Place, neighborReg:Region(3){rect}, shiftDim:Int, forward:Boolean, phase:Byte, periodic:Boolean) {
+        var neighborSent:Boolean = false;
+        val sourcePlace = here;
+        if (neighbor != here) {
+            val overlap = (neighborReg && reg) as Region(3){rect};
+            if (! overlap.isEmpty()) {
+                neighborSent = true;
+                val localPortion = getLocalPortion() as Array[T](3){rect};
+                val neighborPortion = localPortion.getPatch(overlap);
+                @Uncounted at(neighbor) async {
+                    val ghostManager = localHandle().ghostManager;
+                    if (!Runtime.STATIC_THREADS) {
+                        //Console.OUT.println("waiting at " + here + " to deliver ghosts from " + sourcePlace + " phase " + phase);
+                        when (ghostManager.currentPhase() == phase);
+                    }
+                    val local2 = getLocalPortion() as Array[T](3){rect};
+                    local2.copy(neighborPortion, neighborPortion.region);
+                    ghostManager.setNeighborReceived(sourcePlace);
+                    //Console.OUT.println("setNeighborReceived at " + here + " from " + sourcePlace);
+                }
+            }
+        }
+        if (!neighborSent && periodic) {
+            // there may still be a 'neighbor' with PBC
+            val wrap = (region.max(shiftDim)-region.min(shiftDim)+1);
+            val wrapI = shiftDim == 0 ? (forward?-wrap:wrap) : 0;
+            val wrapJ = shiftDim == 1 ? (forward?-wrap:wrap) : 0;
+            val wrapK = shiftDim == 2 ? (forward?-wrap:wrap) : 0;
+            val wrapShift = Point.make(wrapI, wrapJ, wrapK);
+            val wrapReg = (reg + wrapShift) as Region(3){rect};
+            val neighborWrapIncluded = neighborReg && wrapReg;
+            if (!neighborWrapIncluded.isEmpty()) {
+                val overlap = (neighborReg && wrapReg) as Region(3){rect};
+                if (! overlap.isEmpty()) {
+                    neighborSent = true;
+                    val wrapOverlap = (overlap - wrapShift) as Region(3){rect};
+                    val localPortion = getLocalPortion() as Array[T](3){rect};
+                    val neighborPortionWrap = localPortion.getPatch(wrapOverlap);
+                    // need to subtract wrap before sending to neighbor
+                    val neighborPortion = new Array[T](overlap, neighborPortionWrap.raw());
+                    @Uncounted at(neighbor) async {
+                        val ghostManager = localHandle().ghostManager;
+                        if (!Runtime.STATIC_THREADS) {
+                            //Console.OUT.println("waiting at " + here + " to deliver ghosts from " + sourcePlace + " phase " + phase + " periodic");
+                            when (ghostManager.currentPhase() == phase);
+                        }
+                        val local2 = getLocalPortion() as Array[T](3){rect};
+                        local2.copy(neighborPortion, neighborPortion.region);
+                        ghostManager.setNeighborReceived(sourcePlace);
+                        //Console.OUT.println("setNeighborReceived at " + here + " from " + sourcePlace + " periodic");
+                    }
+                }
+            }
+        }
+    }
+
+    public def putOverlap(overlap:Region{rect}, neighborId:Int, phase:Byte) {
+        val neighbor = Place(neighborId);
+        if (rank==3) {
+            putOverlap3(overlap as Region(3){rect}, neighbor, phase);
+        } else {
+            if (!overlap.isEmpty()) {
+                val sourcePlace = here;
+                val localRaw = raw();
+                val g = localRegion();
+                val neighborPortion = new Array[T](overlap, (p:Point(overlap.rank)) => localRaw(g.indexOf(p)) );
+                @Uncounted at(neighbor) async {
+                    val ghostManager = localHandle().ghostManager;
+                    if (!Runtime.STATIC_THREADS) {
+                        //Console.OUT.println("waiting at " + here + " to put ghosts from " + sourcePlace + " phase " + phase + " periodic");
+                        when (ghostManager.currentPhase() == phase);
+                    }
+                    val local2 = getLocalPortion();
+                    val local2Reg = local2.region;
+                    val local2Raw = local2.raw();
+                    for (p in overlap) {
+                        local2Raw(local2Reg.indexOf(p)) = neighborPortion(p);
+                    }
+                    //Console.OUT.println("setting neighbor received " + sourcePlace + " at " + here);
+                    ghostManager.setNeighborReceived(sourcePlace);
+                }
+            }
+        }
+    }
+
+    private def putOverlap3(overlap:Region(3){rect}, place2:Place, phase:Byte) {
+        if (!overlap.isEmpty()) {
+            val sourcePlace = here;
+            val localRaw = raw();
+            val g = localRegion();
+            val localPortion = getLocalPortion() as Array[T](3){rect};
+            val neighborPortion = localPortion.getPatch(overlap);
+            @Uncounted at(place2) async {
+                val ghostManager = localHandle().ghostManager;
+                if (!Runtime.STATIC_THREADS) {
+                    //Console.OUT.println("waiting at " + here + " to put ghosts from " + sourcePlace + " phase " + phase);
+                    when (ghostManager.currentPhase() == phase);
+                }
+                val local2 = getLocalPortion() as Array[T](3){rect};
+                local2.copy(neighborPortion, neighborPortion.region);
+                //Console.OUT.println("setting neighbor received " + sourcePlace + " at " + here);
+                ghostManager.setNeighborReceived(sourcePlace);
+            }
+        }
+    }
+
     public def toString(): String {
         return "DistArray(" + dist + ")";
     }
@@ -763,6 +1215,23 @@
      * @see x10.lang.Iterable[T]#iterator()
      */
     public def iterator(): Iterator[Point(rank)] = region.iterator() as Iterator[Point(rank)];
+
+    protected static @NoInline @NoReturn def raisePlaceError(i0:int) {
+        throw new BadPlaceException("point (" + i0 + ") not defined at " + here);
+    }    
+    protected static @NoInline @NoReturn def raisePlaceError(i0:int, i1:int) {
+        throw new BadPlaceException("point (" + i0 + ", "+i1+") not defined at " + here);
+    }    
+    protected static @NoInline @NoReturn def raisePlaceError(i0:int, i1:int, i2:int) {
+        throw new BadPlaceException("point (" + i0 + ", "+i1+", "+i2+") not defined at " + here);
+    }    
+    protected static @NoInline @NoReturn def raisePlaceError(i0:int, i1:int, i2:int, i3:int) {
+        throw new BadPlaceException("point (" + i0 + ", "+i1+", "+i2+", "+i3+") not defined at " + here);
+    }    
+    protected static @NoInline @NoReturn def raisePlaceError(pt:Point) {
+        throw new BadPlaceException("point " + pt + " not defined at " + here);
+    }  
+
 }
 public type DistArray[T](r:Int) = DistArray[T]{self.rank==r};
 public type DistArray[T](r:Region) = DistArray[T]{self.region==r};
Index: x10.runtime/src-x10/x10/array/Array.x10
===================================================================
--- x10.runtime/src-x10/x10/array/Array.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/Array.x10	(working copy)
@@ -166,6 +166,37 @@
 
     /**
      * Construct an Array over the region reg whose
+     * values are initialized as specified by the init function.
+     * The function will be evaluated exactly once for each point
+     * in reg in an arbitrary order to 
+     * compute the initial value for each array element.</p>
+     * 
+     * It is unspecified whether the function evaluations will
+     * be done sequentially for each point by the current activity 
+     * or concurrently for disjoint sets of points by one or more 
+     * child activities. 
+     * 
+     * @param reg The region over which to construct the array.
+     * @param init The function to use to initialize the array.
+     */    
+    public @Inline def this(reg:Region(3){self.rect}, init:(Int,Int,Int)=>T)
+    {
+        property(reg as Region(3){self.rect,self != null}, reg.rank, reg.rect, reg.zeroBased, reg.rail, reg.size());
+        val crh = new LayoutHelper(reg);
+        layout_min0 = crh.min0;
+        layout_stride1 = crh.stride1;
+        layout_min1 = crh.min1;
+        layout = crh.layout;
+        val n = crh.size;
+        val r  = IndexedMemoryChunk.allocateUninitialized[T](n);
+        for ([i,j,k] in reg) {
+            r(offset(i,j,k))= init(i,j,k);
+        }
+        raw = r;
+    }
+
+    /**
+     * Construct an Array over the region reg whose
      * values are initialized to be init.
      * 
      * @param reg The region over which to construct the array.
@@ -818,6 +849,40 @@
         }
         return accum;
     }
+
+    /**
+     * Apply the function <code>map</code> to the elements of this array and
+     * the other src array and reduce the result using the given 
+     * <code>reduce</code> function and the given initial value.
+     * Each element of the array will be given as an argument to the reduction
+     * function exactly once, but in an arbitrary order.  The reduction function
+     * may be applied concurrently to implement a parallel reduction. 
+     * 
+     * @param map the map function
+     * @param reduce the reduce function
+     * @param unit the given initial value for the reduction
+     * @return the final result of the reduction.
+     * @see #map((T,U)=>S)
+     * @see #reduce((U,T)=>U)
+     */
+    public @Inline def mapReduce[S,U,V](src:Array[U](this.rank), map:(T,U)=>S, reduce:(V,S)=>V, unit:V):V {
+        // TODO: once collecting finish is available,
+        //       use it to efficiently parallelize these loops.
+        var accum:V = unit;
+        if (rect) {
+            // In a rect array, every element in the backing raw IndexedMemoryChunk[T]
+            // is included in the array, therefore we can optimize
+            // the traversal and simply map/reduce on the IndexedMemoryChunk itself.
+            for (i in 0..(raw.length()-1)) {
+                accum = reduce(accum, map(raw(i), src.raw(i)));
+            }          
+        } else {
+            for (p in region) {
+                accum = reduce(accum, map(this(p), src(p)));
+            }
+        }
+        return accum;
+    }
     
     /**
      * Scan this array using the function and the given initial value.
@@ -1159,6 +1224,180 @@
         }
         IndexedMemoryChunk.copy(src.raw, srcIndex, dst.raw, dstIndex, numElems);
     }
+
+    /**
+     * Copy the specified region from the source Array to this array.
+     * If the specified region is not contained in the region for the source
+     * array or this array, then an ArrayIndexOutOfBoundsError is raised.
+     * 
+     * @param src the source array.
+     * @param region the region of the array to copy to this array
+     * 
+     * @see Region#indexOf
+     * 
+     * @throws ArrayIndexOutOfBoundsException if the specified region is not
+     *        contained in the source array or this array
+     */
+    public def copy(src:Array[T](this.rank), r:Region(this.rank)) {
+        if (CompilerFlags.checkBounds()) {
+            if ( !src.region.contains(r)) {
+                throw new ArrayIndexOutOfBoundsException("region to copy: " + r + " not contained in source: " + src.region);
+            } else if (!region.contains(r)) {
+                throw new ArrayIndexOutOfBoundsException("region to copy: " + r + " not contained in this array: " + region);
+            }
+        }
+        if (this.rank==3 && r.rect) {
+            (this as Array[T](3)).copy3(src as Array[T](3), r as Region(3){self.rect});
+            return;
+        }
+
+        val srcRaw = src.raw;
+        if (region == src.region) {
+            // fast path - offset in both arrays is the same
+            for (p in r) {
+                val offset = region.indexOf(p);
+                raw(offset) = srcRaw(offset);
+            }
+        } else {
+            // different offset in each array
+            val min = region.min();
+            val max = region.max();
+            val delta = new Array[Int](rank, (i:Int) => region.max(i) - region.min(i) + 1);
+            val srcMin = src.region.min();
+            val srcMax = src.region.max();
+            val srcDelta = new Array[Int](rank, (i:Int) => src.region.max(i) - src.region.min(i) + 1);
+            for (p in r) {
+                var offset:Int = p(0) - min(0);
+                var srcOffset:Int = p(0) - srcMin(0);
+                for (var i:int=1; i<rank; i++) {
+                    offset = offset*delta(i) + p(i) - min(i);
+                    srcOffset = srcOffset*srcDelta(i) + p(i) - srcMin(i);
+                }
+                raw(offset) = srcRaw(srcOffset);
+            }
+        }
+    }
+
+    private def copy3(src:Array[T](3), r:Region(3){self.rect}){this.rank==3} {
+        val srcRaw = src.raw;
+        if (region == src.region) {
+            // fast path - offset in both arrays is the same
+            for ([i,j,k] in r) {
+                val offset = region.indexOf([i,j,k]);
+                raw(offset) = srcRaw(offset);
+            }
+        } else {
+            val layout_stride2 = layout(0);
+            val layout_stride3 = layout(1);
+
+            val crh = new LayoutHelper(src.region);
+            val src_min0 = crh.min0;
+            val src_max0 = src.region.max(0);
+            val src_stride1 = crh.stride1;
+            val src_min1 = crh.min1;
+            val src_max1 = src.region.max(1);
+            val src_layout = crh.layout;
+            val src_stride2 = src_layout(0);
+            val src_stride3 = src_layout(1);
+            val src_min2 = src.region.min(2);
+            val src_max2 = src.region.max(2);
+
+            for (i0 in src_min0..src_max0) {
+                val offset = (i0 - layout_min0) * layout_stride1;
+                val srcOffset = (i0 - src_min0) * src_stride1;
+                for (i1 in src_min1..src_max1) {
+                    val offset1 = (offset + i1 - layout_min1) * layout_stride2;
+                    val srcOffset1 = (srcOffset + i1 - src_min1) * src_stride2;
+                    for (i2 in src_min2..src_max2) {
+                        val offset2 = offset1 + i2 - layout_stride3;
+                        val srcOffset2 = srcOffset1 + i2 - src_stride3;
+                        raw(offset2) = srcRaw(srcOffset2);
+                    }
+                }
+            }
+        }
+    }
+
+
+    /**
+     * Returns the specified region of this array as a new Array object.
+     * 
+     * @param region the region of the array to copy to this array
+     * 
+     * @see Region#indexOf
+     * 
+     * @throws ArrayIndexOutOfBoundsException if the specified region is not
+     *        contained in this array
+     */
+    public def getPatch(r:Region(this.rank){self.rect}):Array[T](this.rank){self.region==r} {
+        if (CompilerFlags.checkBounds() && !region.contains(r)) {
+            throw new ArrayIndexOutOfBoundsException("region to copy: " + r + " not contained in this array: " + region);
+        }
+        if (this.rank==3) return getPatch3(r as Region(3){self.rect});
+
+        val min = region.min();
+        val max = region.max();
+        val delta = new Array[Int](rank, (i:Int) => region.max(i) - region.min(i) + 1);
+        val dstMin = r.min();
+        val dstMax = r.max();
+        val dstDelta = new Array[Int](rank, (i:Int) => r.max(i) - r.min(i) + 1);
+        val dstRaw = IndexedMemoryChunk.allocateUninitialized[T](r.size());
+        for (p in r) {
+            var offset:Int = p(0) - min(0);
+            var dstOffset:Int = p(0) - dstMin(0);
+            for (var i:int=1; i<rank; i++) {
+                offset = offset*delta(i) + p(i) - min(i);
+                dstOffset = dstOffset*dstDelta(i) + p(i) - dstMin(i);
+            }
+            dstRaw(dstOffset) = raw(offset);
+        }
+        return new Array[T](r, dstRaw);
+    }
+
+    /**
+     * Returns the specified region of this array as a new Array object.
+     * 
+     * @param region the region of the array to copy to this array
+     * 
+     * @see Region#indexOf
+     * 
+     * @throws ArrayIndexOutOfBoundsException if the specified region is not
+     *        contained in this array
+     */
+    private def getPatch3(r:Region(3){self.rect}):Array[T](3){self.region==r} {
+        val dstRaw = IndexedMemoryChunk.allocateUninitialized[T](r.size());
+
+        val layout_stride2 = layout(0);
+        val layout_stride3 = layout(1);
+
+        val crh = new LayoutHelper(r);
+        val dst_min0 = crh.min0;
+        val dst_max0 = r.max(0);
+        val dst_stride1 = crh.stride1;
+        val dst_min1 = crh.min1;
+        val dst_max1 = r.max(1);
+        val dst_layout = crh.layout;
+        val dst_stride2 = dst_layout(0);
+        val dst_stride3 = dst_layout(1); 
+        val dst_min2 = r.min(2);
+        val dst_max2 = r.max(2);
+
+        for (i0 in dst_min0..dst_max0) {
+            val offset = (i0 - layout_min0) * layout_stride1;
+            val dstOffset = (i0 - dst_min0) * dst_stride1;
+            for (i1 in dst_min1..dst_max1) {
+                val offset1 = (offset + i1 - layout_min1) * layout_stride2;
+                val dstOffset1 = (dstOffset + i1 - dst_min1) * dst_stride2;
+                for (i2 in dst_min2..dst_max2) {
+                    val offset2 = offset1 + i2 - layout_stride3;
+                    val dstOffset2 = dstOffset1 + i2 - dst_stride3;
+
+                    dstRaw(dstOffset2) = raw(offset2);
+                }
+            }
+        }
+        return new Array[T](r, dstRaw);
+    }
     
     
     private static @NoInline @NoReturn def raiseBoundsError(i0:int) {
Index: x10.runtime/src-x10/x10/array/BlockBlockDistGhostManagerPut.x10
===================================================================
--- x10.runtime/src-x10/x10/array/BlockBlockDistGhostManagerPut.x10	(revision 0)
+++ x10.runtime/src-x10/x10/array/BlockBlockDistGhostManagerPut.x10	(revision 0)
@@ -0,0 +1,239 @@
+/*
+ *  This file is part of the X10 project (http://x10-lang.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  (C) Copyright Australian National University 2012.
+ */
+
+package x10.array;
+
+import x10.util.ArrayList;
+import x10.util.Team;
+
+/**
+ * A BlockBlockDistGhostManager manages the local ghost region for a DistArray that
+ * is distributed using a BlockBlockDist.
+ * Ghost regions are sent using a simple put algorithm with no internal synchronization.
+ */
+final class BlockBlockDistGhostManagerPut extends GhostManager {
+    val bbd:BlockBlockDist;
+    val neighbors:Rail[GhostNeighborFlag];
+    /** 
+     * The Team over bbd.places over which to execute a barrier operation.
+     * TODO this is a workaround for X10_STATIC_THREADS 
+     */
+    private val team:Team;
+    private val periodic:Boolean;
+
+    public def this(ghostWidth:Int, bbd:Dist, team:Team, periodic:Boolean) {
+        super(ghostWidth);
+        this.bbd = bbd as BlockBlockDist;
+        this.team = team;
+        this.neighbors = getNeighbors(here, periodic);
+/*
+        var neighborString:String = "neighbors at " + here + ":";
+        for ([p] in neighbors) {
+            neighborString += neighbors(p).place + " ";
+        }
+        Console.OUT.println(neighborString);
+        Console.OUT.flush();
+*/
+        this.periodic = periodic;
+    }
+
+    /** 
+     * Gets neighboring places that hold the blocks immediately surrounding
+     * place p.  In a BlockBlockDist, a place may hold two blocks contiguous
+     * in axis0 ("west-east"), so a place may adjoin either one or two
+     * neighboring places in the "north" and "south" directions.
+     * @param p the place for which to return neighboring places
+     * @param periodic whether the dist is wrapped as a PeriodicDist
+     * @return ghost neighbor flags for the places that hold the blocks surrounding p
+     */
+    public def getNeighbors(p:Place, periodic:Boolean):Rail[GhostNeighborFlag] {
+        val b = bbd.region.boundingBox();
+        val axis0 = bbd.axis0;
+        val axis1 = bbd.axis1;
+        val pg = bbd.places();
+        val min0 = b.min(axis0);
+        val max0 = b.max(axis0);
+        val min1 = b.min(axis1);
+        val max1 = b.max(axis1);
+        val size0 = (max0 - min0 + 1);
+        val size1 = (max1 - min1 + 1);
+        val size0Even = size0 % 2 == 0 ? size0 : size0-1;
+        val P = Math.min(pg.numPlaces(), size0Even * size1);
+        val divisions0 = Math.min(size0Even, Math.pow2(Math.ceil((Math.log(P as Double) / Math.log(2.0)) / 2.0) as Int));
+        val divisions1 = Math.min(size1, Math.ceil((P as Double) / divisions0) as Int);
+        val numBlocks = divisions0 * divisions1;
+        val leftOver = numBlocks - P;
+
+        val i = pg.indexOf(p);
+
+        val leftOverOddOffset = (divisions0 % 2 == 0) ? 0 : i*2/(divisions0+1);
+
+        val blockIndex0 = i < leftOver ? (i*2-leftOverOddOffset) % divisions0 : (i+leftOver) % divisions0;
+        val blockIndex1 = i < leftOver ? (i*2) / divisions0 : (i+leftOver) / divisions0;
+
+        val neighbors = new ArrayList[GhostNeighborFlag]();
+        for (x in -1..1) {
+            for (y in -1..1) {
+                if (x != 0 || y !=0) {
+                    var neighborBlockIndex0:Int = (blockIndex0 + x);
+                    var neighborBlockIndex1:Int = (blockIndex1 + y);
+                    if (i < leftOver && x == 1) {
+                        // this place holds two blocks
+                        neighborBlockIndex0++;
+                    }
+                    val groupIndex = getGroupIndex(neighborBlockIndex0, neighborBlockIndex1, divisions0, divisions1, leftOver, periodic, i);
+        //Console.OUT.println("got neighbor for " + p + " neighborBlockIndex0 = " +  neighborBlockIndex0 + " neighborBlockIndex1 = " + neighborBlockIndex1 + " groupIndex = " + groupIndex);
+
+                    val place = pg(groupIndex);
+                    if (place != here) {
+                    neighbors.add(new GhostNeighborFlag(place));
+                        if (x == 0) {
+                            // there may be two neighbors to the north or south
+                            if (i < leftOver && groupIndex >= leftOver) {
+            //Console.OUT.println("got neighbor for " + p + " neighborBlockIndex0 = " +  neighborBlockIndex0 + " neighborBlockIndex1 = " + neighborBlockIndex1 + " groupIndex = " + (groupIndex+1));
+                                val place2 = pg(groupIndex+1);
+                                if (place2 != place) {
+                                    neighbors.add(new GhostNeighborFlag(place2));
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        return neighbors.toArray();
+    }
+    
+    public atomic def setNeighborReceived(place:Place) {
+        for ([p] in neighbors) {
+            val neighborFlag = neighbors(p);
+            if (neighborFlag.place == place) {
+                neighborFlag.received = true;
+                return;
+            }
+        }
+        throw new BadPlaceException("trying to notify neighbor " + place + " received at " + here + " - not a neighbor!");
+    }
+
+    public atomic def allNeighborsReceived():Boolean {
+        for ([p] in neighbors) {
+            val neighborFlag = neighbors(p);
+            if (neighborFlag.received == false) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public atomic def resetNeighborsReceived() {
+        for ([p] in neighbors) {
+            val neighborFlag = neighbors(p);
+            neighborFlag.received = false;
+        }
+    }
+
+    private atomic def setAllNeighborsReceived() {
+        for ([p] in neighbors) {
+            val neighborFlag = neighbors(p);
+            neighborFlag.received = true;
+        }
+    }
+
+    /**
+     * Send ghost data for this place to neighboring places in a BlockBlockDist 
+     * using Plimpton's shift algorithm. Does not include synchronization.
+     * @see Plimpton, S. (1995) "Fast parallel algorithms for Short-Range 
+     * Molecular Dynamics". J. Comput. Phys. 117-1
+     * @see Palmer, B. and Nieplocha, J. (2002) "Efficient Algorithms for Ghost
+     *  Cell Updates on Two Classes of MPP Architectures". PDCS 2002
+     */
+    public def sendGhosts(array:GhostArray) {
+        prepareToSendGhosts();
+        if (Runtime.STATIC_THREADS) {
+            team.barrier(here.id);
+        }
+        val r = bbd(here);
+        if (r.isEmpty()) {
+            setAllNeighborsReceived();
+            return;
+        }
+
+        for ([p] in neighbors) {
+            val neighborFlag = neighbors(p);
+            val place = neighborFlag.place;
+            if (place != here) {
+                val neighborReg = getGhostRegion(place) as Region(r.rank()){rect};
+                val regionToSend = (r && neighborReg) as Region(r.rank()){rect};
+                //Console.OUT.println("putting " + regionToSend + " from " + here + " to " + place);
+                array.putOverlap(regionToSend, place.id, currentPhase());
+            } else {
+                //Console.OUT.println("setting here received at " + here + " for neighbor " + p);
+                neighborFlag.received = true;
+            }
+        }
+    }
+
+    /**
+     * @return the halo region of this region, which is the bounding box 
+     * for this region expanded in each dimension by <code>ghostWidth</code>
+     */
+    public def getGhostRegion(place:Place):Region {
+        val region = bbd(place);
+        if (region.isEmpty()) return region;
+
+        val r = region.boundingBox();
+        val min = new Array[Int](r.rank);
+        val max = new Array[Int](r.rank);
+        for (i in 0..(r.rank-1)) {
+            if (i == bbd.axis0 || i == bbd.axis1) {
+                min(i) = r.min(i) - ghostWidth;
+                max(i) = r.max(i) + ghostWidth;
+            } else {
+                min(i) = r.min(i);
+                max(i) = r.max(i);
+            }
+        }
+        return Region.makeRectangular(min, max);
+    }
+
+    private static def getGroupIndex(var neighborBlockIndex0:Int, var neighborBlockIndex1:Int, divisions0:Int, divisions1:Int, leftOver:Int, periodic:Boolean, groupIndexHere:Int) {
+        if (periodic) {
+            // wrap around
+            if (neighborBlockIndex0 < 0) {
+                neighborBlockIndex0 += divisions0;
+            } else if (neighborBlockIndex0 >= divisions0) {
+                neighborBlockIndex0 -= divisions0;
+            }
+            if (neighborBlockIndex1 < 0) {
+                neighborBlockIndex1 += divisions1;
+            } else if (neighborBlockIndex1 >= divisions1) {
+                neighborBlockIndex1 -= divisions1;
+            }
+        } else {
+            if (neighborBlockIndex0 < 0 
+             || neighborBlockIndex0 >= divisions0
+             || neighborBlockIndex1 < 0
+             || neighborBlockIndex1 >= divisions1) {
+                // no neighbor in this direction
+                return groupIndexHere;
+            }
+        }
+        val groupIndex:Int;
+        val neighborBlockIndex = (neighborBlockIndex1 * divisions0) + neighborBlockIndex0;
+        if (neighborBlockIndex <= leftOver * 2) {
+            groupIndex = (neighborBlockIndex / 2) as Int;
+        } else {
+            groupIndex = (neighborBlockIndex - leftOver);
+        }
+        return groupIndex;
+    }
+}
+

Property changes on: x10.runtime/src-x10/x10/array/BlockBlockDistGhostManagerPut.x10
___________________________________________________________________
Added: svn:mime-type
   + text/plain
Added: svn:eol-style
   + native

Index: x10.runtime/src-x10/x10/array/BlockBlockDistGhostManager.x10
===================================================================
--- x10.runtime/src-x10/x10/array/BlockBlockDistGhostManager.x10	(revision 0)
+++ x10.runtime/src-x10/x10/array/BlockBlockDistGhostManager.x10	(revision 0)
@@ -0,0 +1,312 @@
+/*
+ *  This file is part of the X10 project (http://x10-lang.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  (C) Copyright Australian National University 2011.
+ */
+
+package x10.array;
+
+import x10.util.ArrayList;
+import x10.util.Team;
+
+/**
+ * A BlockBlockDistGhostManager manages the local ghost region for a DistArray that
+ * is distributed using a BlockBlockDist.
+ */
+final class BlockBlockDistGhostManager extends GhostManager {
+    val bbd:BlockBlockDist;
+    val leftNeighbor:GhostNeighborFlag;
+    val rightNeighbor:GhostNeighborFlag;
+    val topLeftNeighbor:GhostNeighborFlag;
+    val topRightNeighbor:GhostNeighborFlag;
+    val bottomLeftNeighbor:GhostNeighborFlag;
+    val bottomRightNeighbor:GhostNeighborFlag;
+    /** 
+     * The Team over bbd.places over which to execute a barrier operation.
+     * TODO this is a workaround for X10_STATIC_THREADS 
+     */
+    private val team:Team;
+    private val periodic:Boolean;
+
+    public def this(ghostWidth:Int, bbd:BlockBlockDist, team:Team, periodic:Boolean) {
+        super(ghostWidth);
+        this.bbd = bbd;
+        this.team = team;
+
+        val b = bbd.region.boundingBox();
+        val axis0 = bbd.axis0;
+        val axis1 = bbd.axis1;
+        val pg = bbd.places();
+        val min0 = b.min(axis0);
+        val max0 = b.max(axis0);
+        val min1 = b.min(axis1);
+        val max1 = b.max(axis1);
+        val size0 = (max0 - min0 + 1);
+        val size1 = (max1 - min1 + 1);
+        val size0Even = size0 % 2 == 0 ? size0 : size0-1;
+        val P = Math.min(pg.numPlaces(), size0Even * size1);
+        val divisions0 = Math.min(size0Even, Math.pow2(Math.ceil((Math.log(P as Double) / Math.log(2.0)) / 2.0) as Int));
+        val divisions1 = Math.min(size1, Math.ceil((P as Double) / divisions0) as Int);
+                val numBlocks = divisions0 * divisions1;
+        val leftOver = numBlocks - P;
+
+        val i = pg.indexOf(here);
+
+        val leftOverOddOffset = (divisions0 % 2 == 0) ? 0 : i*2/(divisions0+1);
+
+        val blockIndex0 = i < leftOver ? (i*2-leftOverOddOffset) % divisions0 : (i+leftOver) % divisions0;
+        val blockIndex1 = i < leftOver ? (i*2) / divisions0 : (i+leftOver) / divisions0;
+
+        leftNeighbor        = new GhostNeighborFlag(pg(getGroupIndex(blockIndex0-1, blockIndex1, divisions0, divisions1, leftOver, periodic, i)));
+        val topLeft = getGroupIndex(blockIndex0, blockIndex1-1, divisions0, divisions1, leftOver, periodic, i);
+        topLeftNeighbor     = new GhostNeighborFlag(pg(topLeft));
+        val bottomLeft = getGroupIndex(blockIndex0, blockIndex1+1, divisions0, divisions1, leftOver, periodic, i);
+        bottomLeftNeighbor  = new GhostNeighborFlag(pg(bottomLeft));
+        if (i < leftOver) {
+            rightNeighbor       = new GhostNeighborFlag(pg(getGroupIndex(blockIndex0+2, blockIndex1, divisions0, divisions1, leftOver, periodic, i)));
+            if (topLeft >= leftOver) {
+                topRightNeighbor    = new GhostNeighborFlag(pg(getGroupIndex(blockIndex0+1, blockIndex1-1, divisions0, divisions1, leftOver, periodic, i)));
+            } else {
+                topRightNeighbor    = new GhostNeighborFlag(pg(i));
+            }
+            if (bottomLeft >= leftOver) {
+                bottomRightNeighbor = new GhostNeighborFlag(pg(getGroupIndex(blockIndex0+1, blockIndex1+1, divisions0, divisions1, leftOver, periodic, i)));
+            } else {
+                bottomRightNeighbor    = new GhostNeighborFlag(pg(i));
+            }
+        } else {
+            rightNeighbor       = new GhostNeighborFlag(pg(getGroupIndex(blockIndex0+1, blockIndex1, divisions0, divisions1, leftOver, periodic, i)));
+            topRightNeighbor    = new GhostNeighborFlag(pg(i));
+            bottomRightNeighbor = new GhostNeighborFlag(pg(i));
+        }
+        this.periodic = periodic;
+    }
+
+    public def printNeighbors() {
+        Console.OUT.println("at " + here 
+                          + " left = " + leftNeighbor.place 
+                          + " right = " + rightNeighbor.place
+                          + " topLeft = " + topLeftNeighbor.place 
+                          + " topRight = " + topRightNeighbor.place 
+                          + " bottomLeft = " + bottomLeftNeighbor.place 
+                          + " bottomRight = " + bottomRightNeighbor.place);
+    }
+
+    /**
+     * @return the halo region of this region, which is the bounding box 
+     * for this region expanded in each dimension by <code>ghostWidth</code>
+     */
+    public def getGhostRegion(place:Place):Region {
+        val region = bbd(place);
+        if (region.isEmpty()) return region;
+
+        val r = region.boundingBox();
+        val min = new Array[Int](r.rank);
+        val max = new Array[Int](r.rank);
+        for (i in 0..(r.rank-1)) {
+            if (i == bbd.axis0 || i == bbd.axis1) {
+                min(i) = r.min(i) - ghostWidth;
+                max(i) = r.max(i) + ghostWidth;
+            } else {
+                min(i) = r.min(i);
+                max(i) = r.max(i);
+            }
+        }
+        return Region.makeRectangular(min, max);
+    }
+    
+    public atomic def setNeighborReceived(place:Place) {
+        if (topLeftNeighbor.place==place && topLeftNeighbor.received==false) {
+            topLeftNeighbor.received = true;
+            //Console.OUT.println("notified topLeftNeighbor " + place + " at " + here);
+        } else if (topRightNeighbor.place==place && topRightNeighbor.received==false) {
+            topRightNeighbor.received = true;
+            //Console.OUT.println("notified topRightNeighbor " + place + " at " + here);
+        } else if (bottomLeftNeighbor.place==place && bottomLeftNeighbor.received==false) {
+            bottomLeftNeighbor.received = true;
+            //Console.OUT.println("notified bottomLeftNeighbor " + place + " at " + here);
+        } else if (bottomRightNeighbor.place==place && bottomRightNeighbor.received==false) {
+            bottomRightNeighbor.received = true;
+            //Console.OUT.println("notified bottomRightNeighbor " + place + " at " + here);
+        } else if (leftNeighbor.place==place && leftNeighbor.received==false) {
+            leftNeighbor.received = true;
+            //Console.OUT.println("notified leftNeighbor " + place + " at " + here);
+        } else if (rightNeighbor.place==place && rightNeighbor.received==false) {
+            rightNeighbor.received = true;
+            //Console.OUT.println("notified rightNeighbor " + place + " at " + here);
+        } else {
+            throw new BadPlaceException("trying to notify neighbor " + place + " received at " + here + " - not a neighbor!");
+        }
+    }
+
+    public atomic def allNeighborsReceived():Boolean {
+        return leftNeighbor.received
+            && rightNeighbor.received
+            && topLeftNeighbor.received 
+            && topRightNeighbor.received
+            && bottomLeftNeighbor.received
+            && bottomRightNeighbor.received;
+
+    }
+
+    public atomic final def axis1NeighborsReceived():Boolean {
+        return topLeftNeighbor.received 
+            && topRightNeighbor.received
+            && bottomLeftNeighbor.received
+            && bottomRightNeighbor.received;
+    }
+
+    public atomic def resetNeighborsReceived() {
+        leftNeighbor.received = false;
+        rightNeighbor.received = false;
+        topLeftNeighbor.received = false;
+        topRightNeighbor.received = false;
+        bottomLeftNeighbor.received = false;
+        bottomRightNeighbor.received = false;
+    }
+
+    private atomic def setAllNeighborsReceived() {
+        leftNeighbor.received = true;
+        rightNeighbor.received = true;
+        topLeftNeighbor.received = true;
+        topRightNeighbor.received = true;
+        bottomLeftNeighbor.received = true;
+        bottomRightNeighbor.received = true;
+    }
+
+    /**
+     * Send ghost data for this place to neighboring places in a BlockBlockDist 
+     * using Plimpton's shift algorithm. Does not include synchronization.
+     * @see Plimpton, S. (1995) "Fast parallel algorithms for Short-Range 
+     * Molecular Dynamics". J. Comput. Phys. 117-1
+     * @see Palmer, B. and Nieplocha, J. (2002) "Efficient Algorithms for Ghost
+     *  Cell Updates on Two Classes of MPP Architectures". PDCS 2002
+     */
+    public def sendGhosts(array:GhostArray) {
+        prepareToSendGhosts();
+        if (Runtime.STATIC_THREADS) {
+            team.barrier(here.id);
+        }
+        val r = bbd(here);
+        if (r.isEmpty()) {
+            setAllNeighborsReceived();
+            return;
+        }
+
+        // send to neighboring places in one direction along axis1
+        if (periodic || topLeftNeighbor.place != here) {
+            val topMin = new Array[Int](r.rank, (i:Int) => r.min(i));
+            val topMax = new Array[Int](r.rank, (i:Int) => i==bbd.axis1 ? r.min(i)+ghostWidth-1 : r.max(i));
+            val topReg = Region.makeRectangular(topMin, topMax);
+
+            val topLeftNeighborReg = getGhostRegion(topLeftNeighbor.place) as Region(topReg.rank){rect};
+            array.sendToNeighbor(topReg, topLeftNeighbor.place.id, topLeftNeighborReg, bbd.axis1, false, currentPhase(), periodic);
+            if (topRightNeighbor.place != here && topRightNeighbor.place != topLeftNeighbor.place) {
+                //Console.OUT.println("sending to " + topRightNeighbor.place + " from " + here);
+                val topRightNeighborReg = getGhostRegion(topRightNeighbor.place) as Region(topReg.rank){rect};
+                array.sendToNeighbor(topReg, topRightNeighbor.place.id, topRightNeighborReg, bbd.axis1, false, currentPhase(), periodic);
+            } else {
+                topRightNeighbor.received = true;
+                //Console.OUT.println("notified topRightNeighbor here at " + here);
+            }
+        } else {
+            topLeftNeighbor.received = true;
+            topRightNeighbor.received = true;
+            //Console.OUT.println("notified topLeftNeighbor and topRightNeighbor here at " + here);
+        }
+
+
+        // send to neighboring places in the opposite direction along axis1
+        if (periodic || bottomLeftNeighbor.place != here) {
+            val bottomMin = new Array[Int](r.rank, (i:Int) => i==bbd.axis1 ? r.max(i)-ghostWidth+1 : r.min(i));
+            val bottomMax = new Array[Int](r.rank, (i:Int) => r.max(i));
+            val bottomReg = Region.makeRectangular(bottomMin, bottomMax);
+
+            val bottomLeftNeighborReg = getGhostRegion(bottomLeftNeighbor.place) as Region(bottomReg.rank){rect};
+            array.sendToNeighbor(bottomReg, bottomLeftNeighbor.place.id, bottomLeftNeighborReg, bbd.axis1, true, currentPhase(), periodic);
+            if (bottomRightNeighbor.place != here && bottomRightNeighbor.place != bottomLeftNeighbor.place) {
+                //Console.OUT.println("sending to " + bottomRightNeighbor.place + " from " + here);
+                val bottomRightNeighborReg = getGhostRegion(bottomRightNeighbor.place) as Region(bottomReg.rank){rect};
+                array.sendToNeighbor(bottomReg, bottomRightNeighbor.place.id, bottomRightNeighborReg, bbd.axis1, true, currentPhase(), periodic);
+            } else {
+                bottomRightNeighbor.received = true;
+                //Console.OUT.println("notified bottomRightNeighbor here at " + here);
+            }
+        } else {
+            bottomLeftNeighbor.received = true;
+            bottomRightNeighbor.received = true;
+            //Console.OUT.println("notified bottomLeftNeighbor and bottomRightNeighbor here at " + here);
+        }
+
+        // HACK - check for incoming messages for neighbors before blocking wait
+        //Runtime.probe();
+
+        //Console.OUT.println("waiting on axis1 at " + here);
+        when(axis1NeighborsReceived());
+        //Console.OUT.println("progressed on axis1 at " + here);
+
+        // send to neighboring place in one direction along axis0
+        if (periodic || leftNeighbor.place != here) {
+            val leftMin = new Array[Int](r.rank, (i:Int) => i==bbd.axis1 ? r.min(i)-ghostWidth : r.min(i));
+            val leftMax = new Array[Int](r.rank, (i:Int) => i==bbd.axis0 ? r.min(i)+ghostWidth-1 : (i==bbd.axis1 ? r.max(i)+ghostWidth : r.max(i)));
+            val leftReg = Region.makeRectangular(leftMin, leftMax);
+
+            val leftNeighborReg = getGhostRegion(leftNeighbor.place) as Region(leftReg.rank){rect};
+            array.sendToNeighbor(leftReg, leftNeighbor.place.id, leftNeighborReg, bbd.axis0, false, currentPhase(), periodic);
+        } else {
+            leftNeighbor.received = true;
+            //Console.OUT.println("notified leftNeighbor here at " + here);
+        }
+
+        // send to neighboring place in the opposite direction along axis0
+        if (periodic || rightNeighbor.place != here) {
+            val rightMin = new Array[Int](r.rank, (i:Int) => i==bbd.axis0 ? r.max(i)-ghostWidth+1 : (i==bbd.axis1 ? r.min(i)-ghostWidth : r.min(i)));
+            val rightMax = new Array[Int](r.rank, (i:Int) => i==bbd.axis1 ? r.max(i)+ghostWidth : r.max(i));
+            val rightReg = Region.makeRectangular(rightMin, rightMax);
+
+            val rightNeighborReg = getGhostRegion(rightNeighbor.place) as Region(rightReg.rank){rect};
+            array.sendToNeighbor(rightReg, rightNeighbor.place.id, rightNeighborReg, bbd.axis0, true, currentPhase(), periodic);
+        } else {
+            rightNeighbor.received = true;
+            //Console.OUT.println("notified rightNeighbor here at " + here);
+        }
+    }
+
+    private static def getGroupIndex(var neighborBlockIndex0:Int, var neighborBlockIndex1:Int, divisions0:Int, divisions1:Int, leftOver:Int, periodic:Boolean, groupIndexHere:Int) {
+        if (periodic) {
+            // wrap around
+            if (neighborBlockIndex0 < 0) {
+                neighborBlockIndex0 += divisions0;
+            } else if (neighborBlockIndex0 >= divisions0) {
+                neighborBlockIndex0 -= divisions0;
+            }
+            if (neighborBlockIndex1 < 0) {
+                neighborBlockIndex1 += divisions1;
+            } else if (neighborBlockIndex1 >= divisions1) {
+                neighborBlockIndex1 -= divisions1;
+            }
+        } else {
+            if (neighborBlockIndex0 < 0 
+             || neighborBlockIndex0 >= divisions0
+             || neighborBlockIndex1 < 0
+             || neighborBlockIndex1 >= divisions1) {
+                // no neighbor in this direction
+                return groupIndexHere;
+            }
+        }
+        val groupIndex:Int;
+        val neighborBlockIndex = (neighborBlockIndex1 * divisions0) + neighborBlockIndex0;
+        if (neighborBlockIndex <= leftOver * 2) {
+            groupIndex = (neighborBlockIndex / 2) as Int;
+        } else {
+            groupIndex = (neighborBlockIndex - leftOver);
+        }
+        return groupIndex;
+    }
+}
+

Property changes on: x10.runtime/src-x10/x10/array/BlockBlockDistGhostManager.x10
___________________________________________________________________
Added: svn:mime-type
   + text/plain
Added: svn:eol-style
   + native

Index: x10.runtime/src-x10/x10/array/BlockBlockDist.x10
===================================================================
--- x10.runtime/src-x10/x10/array/BlockBlockDist.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/BlockBlockDist.x10	(working copy)
@@ -12,6 +12,9 @@
 package x10.array;
 
 import x10.compiler.CompilerFlags;
+import x10.util.ArrayList;
+import x10.util.Pair;
+import x10.util.Team;
 
 /**
  * <p>A BlockBlock distribution maps points in its region
@@ -34,12 +37,12 @@
     /**
      * The first axis along which the region is distributed
      */
-    private val axis0:int;
+    public val axis0:int;
 
     /**
      * The second axis along which the region is distributed
      */
-    private val axis1:int;
+    public val axis1:int;
 
     /**
      * Cached restricted region for the current place.
@@ -235,61 +238,6 @@
         if (CompilerFlags.checkBounds() && !region.contains(pt)) raiseBoundsError(pt);
         return mapIndexToPlace(pt(axis0), pt(axis1));
     }
-
-    public def offset(pt:Point(rank)):int {
-        val r = get(here);
-        val offset = r.indexOf(pt);
-        if (offset == -1) {
-            if (CompilerFlags.checkBounds() && !region.contains(pt)) raiseBoundsError(pt);
-            if (CompilerFlags.checkPlace()) raisePlaceError(pt);
-        }
-        return offset;
-    }
-
-    public def offset(i0:int){rank==1}:int {
-        val r = get(here);
-        val offset = r.indexOf(i0);
-        if (offset == -1) {
-            if (CompilerFlags.checkBounds() && !region.contains(i0)) raiseBoundsError(i0);
-            if (CompilerFlags.checkPlace()) raisePlaceError(i0);
-        }
-        return offset;
-    }
-
-    public def offset(i0:int, i1:int){rank==2}:int {
-        val r = get(here);
-	    val offset = r.indexOf(i0,i1);
-	    if (offset == -1) {
-	        if (CompilerFlags.checkBounds() && !region.contains(i0,i1)) raiseBoundsError(i0,i1);
-            if (CompilerFlags.checkPlace()) raisePlaceError(i0,i1);
-        }
-        return offset;
-    }
-
-    public def offset(i0:int, i1:int, i2:int){rank==3}:int {
-        val r = get(here);
-	    val offset = r.indexOf(i0,i1,i2);
-	    if (offset == -1) {
-	        if (CompilerFlags.checkBounds() && !region.contains(i0,i1,i2)) raiseBoundsError(i0,i1,i2);
-            if (CompilerFlags.checkPlace()) raisePlaceError(i0,i1,i2);
-        }
-        return offset;
-    }
-
-    public def offset(i0:int, i1:int, i2:int, i3:int){rank==4}:int {
-        val r = get(here);
-	    val offset = r.indexOf(i0,i1,i2,i3);
-	    if (offset == -1) {
-	        if (CompilerFlags.checkBounds() && !region.contains(i0,i1,i2,i3)) raiseBoundsError(i0,i1,i2,i3);
-            if (CompilerFlags.checkPlace()) raisePlaceError(i0,i1,i2,i3);
-        }
-        return offset;
-    }
-
-    public def maxOffset() {
-        val r = get(here);
-        return r.size()-1;
-    }
         
     public def restriction(r:Region(rank)):Dist(rank) {
         return new WrappedDistRegionRestricted(this, r) as Dist(rank); // TODO: cast should not be needed
@@ -299,6 +247,9 @@
         return new WrappedDistPlaceRestricted(this, p) as Dist(rank); // TODO: cast should not be needed
     }
 
+    public def getLocalGhostManager(ghostWidth:Int, team:Team, periodic:Boolean) {
+        return new BlockBlockDistGhostManager(ghostWidth, this, team, periodic);
+    }
 
     public def equals(thatObj:Any):boolean {
         if (!(thatObj instanceof BlockBlockDist)) return false;
Index: x10.runtime/src-x10/x10/array/BlockDistGhostManager.x10
===================================================================
--- x10.runtime/src-x10/x10/array/BlockDistGhostManager.x10	(revision 0)
+++ x10.runtime/src-x10/x10/array/BlockDistGhostManager.x10	(revision 0)
@@ -0,0 +1,149 @@
+/*
+ *  This file is part of the X10 project (http://x10-lang.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  (C) Copyright Australian National University 2011.
+ */
+
+package x10.array;
+
+import x10.util.Team;
+
+/**
+ * A BlockDistGhostManager manages the local ghost region for a DistArray that
+ * is distributed using a BlockDist.
+ */
+final class BlockDistGhostManager extends GhostManager {
+    private val bd:BlockDist;
+    private val leftNeighbor:GhostNeighborFlag;
+    private val rightNeighbor:GhostNeighborFlag;
+    /** 
+     * The Team over bbd.places over which to execute a barrier operation.
+     * TODO this is a workaround for X10_STATIC_THREADS 
+     */
+    private val team:Team;
+    private val periodic:Boolean;
+
+    public def this(ghostWidth:Int, bd:BlockDist, team:Team, periodic:Boolean) {
+        super(ghostWidth);
+        this.bd = bd;
+        this.team = team;
+
+        val pg = bd.places();
+
+        val i = pg.indexOf(here);
+        val left:Place;
+        val right:Place;
+        if (i>0) {
+            left = pg(i-1);
+        } else if (periodic) {
+            left = pg(pg.size()-1);
+        } else {
+            left = here;
+        }
+        this.leftNeighbor = new GhostNeighborFlag(left);
+
+        if (i<(pg.size()-1)) {
+            right = pg(i+1);
+        } else if (periodic) {
+            right = pg(0);
+        } else {
+            right = here;
+        }
+        this.rightNeighbor = new GhostNeighborFlag(right);
+        this.periodic = periodic;
+    }
+
+    /**
+     * @return the halo region of this region, which is the bounding box 
+     * for this region expanded in along bd.axis by <code>ghostWidth</code>
+     */
+    public def getGhostRegion(place:Place):Region {
+        val region = bd(place);
+        if (region.isEmpty()) return region;
+
+        val r = region.boundingBox();
+        val min = new Array[Int](r.rank);
+        val max = new Array[Int](r.rank);
+        for (i in 0..(r.rank-1)) {
+            if (i == bd.axis) {
+                min(i) = r.min(i) - ghostWidth;
+                max(i) = r.max(i) + ghostWidth;
+            } else {
+                min(i) = r.min(i);
+                max(i) = r.max(i);
+            }
+        }
+        return Region.makeRectangular(min, max);
+    }
+    
+    public atomic def setNeighborReceived(place:Place) {
+        if (leftNeighbor.place==place && leftNeighbor.received==false) {
+            leftNeighbor.received = true;
+            //Console.OUT.println("notified leftNeighbor " + place + " at " + here);
+        } else if (rightNeighbor.place==place && rightNeighbor.received==false) {
+            rightNeighbor.received = true;
+            //Console.OUT.println("notified rightNeighbor " + place + " at " + here);
+        } else {
+            throw new BadPlaceException("trying to notify neighbor " + place + " received at " + here + " - not a neighbor!");
+        }
+    }
+
+    public atomic def allNeighborsReceived():Boolean {
+        return leftNeighbor.received && rightNeighbor.received;
+    }
+
+    public atomic def resetNeighborsReceived() {
+        leftNeighbor.received = false;
+        rightNeighbor.received = false;
+    }
+
+    private atomic def setAllNeighborsReceived() {
+        leftNeighbor.received = true;
+        rightNeighbor.received = true;
+    }
+
+    /**
+     * Send ghost data for this place to neighboring places in a BlockDist.
+     * As this DistArray is only divided along one axis, data only need
+     * to be sent along that axis.
+     */
+    public def sendGhosts(array:GhostArray) {
+        prepareToSendGhosts();
+        if (Runtime.STATIC_THREADS) {
+            team.barrier(here.id);
+        }
+        val r = bd(here);
+        if (r.isEmpty()) {
+            setAllNeighborsReceived();
+            return;
+        }
+
+        if (periodic || leftNeighbor.place != here) {
+            val leftMin = new Array[Int](r.rank, (i:Int) => r.min(i));
+            val leftMax = new Array[Int](r.rank, (i:Int) => i==bd.axis ? r.min(i)+ghostWidth-1 : r.max(i));
+            val leftReg = Region.makeRectangular(leftMin, leftMax);
+            val leftNeighborReg = getGhostRegion(leftNeighbor.place) as Region(leftReg.rank){rect};
+            array.sendToNeighbor(leftReg, leftNeighbor.place.id, leftNeighborReg, bd.axis, false, currentPhase(), periodic);
+        } else {
+            leftNeighbor.received = true;
+            //Console.OUT.println("notified leftNeighbor here at " + here);
+        }
+
+        if (periodic || rightNeighbor.place != here) {
+            val rightMin = new Array[Int](r.rank, (i:Int) => i==bd.axis ? r.max(i)-ghostWidth+1 : r.min(i));
+            val rightMax = new Array[Int](r.rank, (i:Int) => r.max(i));
+            val rightReg = Region.makeRectangular(rightMin, rightMax);
+            val rightNeighborReg = getGhostRegion(rightNeighbor.place) as Region(rightReg.rank){rect};
+            array.sendToNeighbor(rightReg, rightNeighbor.place.id, rightNeighborReg, bd.axis, true, currentPhase(), periodic);
+        } else {
+            rightNeighbor.received = true;
+            //Console.OUT.println("notified rightNeighbor here at " + here);
+        }
+    }
+}
+

Property changes on: x10.runtime/src-x10/x10/array/BlockDistGhostManager.x10
___________________________________________________________________
Added: svn:mime-type
   + text/plain
Added: svn:eol-style
   + native

Index: x10.runtime/src-x10/x10/array/BlockDist.x10
===================================================================
--- x10.runtime/src-x10/x10/array/BlockDist.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/BlockDist.x10	(working copy)
@@ -13,6 +13,8 @@
 
 import x10.compiler.CompilerFlags;
 
+import x10.util.Team;
+
 /**
  * <p>A BlockDist divides the coordinates along one axis
  * of its Region in a block fashion and distributes them
@@ -35,7 +37,7 @@
     /**
      * The axis along which the region is being distributed
      */
-    private val axis:int;
+    public val axis:int;
 
     /**
      * Cached restricted region for the current place.
@@ -113,7 +115,6 @@
         }
     }
     
-    
     public def places():PlaceGroup = pg;
     
     public def numPlaces():int = pg.numPlaces();
@@ -178,62 +179,6 @@
         default: return here; // UNREACHABLE
         }
     }
-
-    public def offset(pt:Point(rank)):int {
-        val r = get(here);
-        val offset = r.indexOf(pt);
-        if (offset == -1) {
-            if (CompilerFlags.checkBounds() && !region.contains(pt)) raiseBoundsError(pt);
-            if (CompilerFlags.checkPlace()) raisePlaceError(pt);
-        }
-        return offset;
-    }
-
-
-    public def offset(i0:int){rank==1}:int {
-        val r = get(here);
-        val offset = r.indexOf(i0);
-        if (offset == -1) {
-            if (CompilerFlags.checkBounds() && !region.contains(i0)) raiseBoundsError(i0);
-            if (CompilerFlags.checkPlace()) raisePlaceError(i0);
-        }
-        return offset;
-    }
-
-    public def offset(i0:int, i1:int){rank==2}:int {
-        val r = get(here);
-        val offset = r.indexOf(i0,i1);
-        if (offset == -1) {
-            if (CompilerFlags.checkBounds() && !region.contains(i0,i1)) raiseBoundsError(i0,i1);
-            if (CompilerFlags.checkPlace()) raisePlaceError(i0,i1);
-        }
-        return offset;
-    }
-
-    public def offset(i0:int, i1:int, i2:int){rank==3}:int {
-        val r = get(here);
-        val offset = r.indexOf(i0,i1,i2);
-        if (offset == -1) {
-            if (CompilerFlags.checkBounds() && !region.contains(i0,i1,i2)) raiseBoundsError(i0,i1,i2);
-            if (CompilerFlags.checkPlace()) raisePlaceError(i0,i1,i2);
-        }
-        return offset;
-    }
-
-    public def offset(i0:int, i1:int, i2:int, i3:int){rank==4}:int {
-        val r = get(here);
-        val offset = r.indexOf(i0,i1,i2,i3);
-        if (offset == -1) {
-            if (CompilerFlags.checkBounds() && !region.contains(i0,i1,i2,i3)) raiseBoundsError(i0,i1,i2,i3);
-            if (CompilerFlags.checkPlace()) raisePlaceError(i0,i1,i2,i3);
-        }
-        return offset;
-    }
-
-    public def maxOffset() {
-        val r = get(here);
-        return r.size()-1;
-    }
         
     public def restriction(r:Region(rank)):Dist(rank) {
         return new WrappedDistRegionRestricted(this, r) as Dist(rank); // TODO: cast should not be needed
@@ -243,6 +188,9 @@
         return new WrappedDistPlaceRestricted(this, p) as Dist(rank); // TODO: cast should not be needed
     }
 
+    public def getLocalGhostManager(ghostWidth:Int, team:Team, periodic:Boolean) {
+        return new BlockDistGhostManager(ghostWidth, this, team, periodic);
+    }
     
     public def equals(thatObj:Any):boolean {
         if (this == thatObj) return true;
Index: x10.runtime/src-x10/x10/array/ConstantDist.x10
===================================================================
--- x10.runtime/src-x10/x10/array/ConstantDist.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/ConstantDist.x10	(working copy)
@@ -73,55 +73,6 @@
         return onePlace;
     }
     
-    public def offset(pt:Point(rank)):int {
-        if (CompilerFlags.checkPlace() && here!=onePlace) raisePlaceError(pt);
-        val offset = region.indexOf(pt);
-        if (CompilerFlags.checkBounds() && offset == -1) {
-            raiseBoundsError(pt);
-        }
-        return offset;
-    }
-    
-    public def offset(i0:int){rank==1}:int {
-        if (CompilerFlags.checkPlace() && here!=onePlace) raisePlaceError(i0);
-        val offset = region.indexOf(i0);
-        if (CompilerFlags.checkBounds() && offset == -1) {
-            raiseBoundsError(i0);
-        }
-        return offset;
-    }
-    
-    public def offset(i0:int, i1:int){rank==2}:int {
-        if (CompilerFlags.checkPlace() && here!=onePlace) raisePlaceError(i0, i1);
-        val offset = region.indexOf(i0, i1);
-        if (CompilerFlags.checkBounds() && offset == -1) {
-            raiseBoundsError(i0, i1);
-        }
-        return offset;
-    }
-    
-    public def offset(i0:int, i1:int, i2:int){rank==3}:int {
-        if (CompilerFlags.checkPlace() && here!=onePlace) raisePlaceError(i0, i1, i2);
-        val offset = region.indexOf(i0, i1, i2);
-        if (CompilerFlags.checkBounds() && offset == -1) {
-            raiseBoundsError(i0, i1, i2);
-        }
-        return offset;
-    }
-    
-    public def offset(i0:int, i1:int, i2:int, i3:int){rank==4}:int {
-        if (CompilerFlags.checkPlace() && here!=onePlace) raisePlaceError(i0, i1, i2, i3);
-        val offset = region.indexOf(i0, i1, i2, i3);
-        if (CompilerFlags.checkBounds() && offset == -1) {
-            raiseBoundsError(i0, i1, i2, i3);
-        }
-        return offset;
-    }
-    
-    public def maxOffset() {
-        return region.size();
-    }
-    
     public def restriction(r:Region(rank)):Dist(rank) {
         return new WrappedDistRegionRestricted(this, r) as Dist(rank); // TODO: cast should not be needed
     }
Index: x10.runtime/src-x10/x10/array/DistArray.x10
===================================================================
--- x10.runtime/src-x10/x10/array/DistArray.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/DistArray.x10	(working copy)
@@ -14,15 +14,18 @@
 import x10.compiler.CompilerFlags;
 import x10.compiler.Header;
 import x10.compiler.Inline;
+import x10.compiler.Mutable;
 import x10.compiler.Native;
 import x10.compiler.NoInline;
 import x10.compiler.NoReturn;
 import x10.compiler.Incomplete;
+import x10.compiler.Uncounted;
 
 import x10.io.CustomSerialization;
 import x10.io.SerialData;
 
 import x10.util.IndexedMemoryChunk;
+import x10.util.Team;
 
 /**
  * <p>A distributed array (DistArray) defines a mapping from {@link Point}s to data 
@@ -53,7 +56,8 @@
     dist:Dist
 ) implements (Point(dist.region.rank))=>T,
              Iterable[Point(dist.region.rank)],
-             CustomSerialization
+             CustomSerialization,
+             GhostArray
 {
 
     //
@@ -70,10 +74,14 @@
      */
     public property rank(): int = dist.rank;
 
-    protected static class LocalState[T](dist:Dist, data:IndexedMemoryChunk[T]) {
-      public def this(d:Dist, c:IndexedMemoryChunk[T]) { 
-          property(d, c);
+    public def getDist() = dist;
 
+    protected static class LocalState[T](dist:Dist, data:IndexedMemoryChunk[T], ghostRegion:Region) {
+      public val ghostManager:GhostManager;
+      public def this(d:Dist, c:IndexedMemoryChunk[T], r:Region, ghostManager:GhostManager) {
+          property(d, c, r);
+          this.ghostManager = ghostManager;
+
           // Calling operator this here serves to force initialization of any 
           // cached local state in the Dist object.  The main reason for doing
           // this is to avoid lazy creation of this state (and thus allocation) 
@@ -82,32 +90,70 @@
       }
     }
 
+    private static def getGhostManager(d:Dist, team:Team, ghostWidth:Int, periodic:Boolean) {
+        if (ghostWidth < 1) return null;
+
+        if (!periodic && d.numPlaces() == 1) return null;
+
+        return d.getLocalGhostManager(ghostWidth, team, periodic);
+    }
+
+    /** @return a team over the places in dist. TODO a workaround for X10_STATIC_THREADS */
+    private def getTeamOverPlaces():Team {
+        val team:Team;
+        val pg = dist.places();
+        if (pg == PlaceGroup.WORLD) {
+            team = Team.WORLD;
+        } else {
+            val places = new Array[Place](pg.size(), (i:Int) => pg(i));
+            team = new Team(places);
+        }
+        return team;
+    }
+
     /** The place-local backing storage for the DistArray */
     protected val localHandle:PlaceLocalHandle[LocalState[T]];
-    /** Can the backing storage be obtained from cachedRaw? */
-    protected transient var cachedRawValid:boolean;
+    /** Have cachedRaw / cachedGhostRegion been set? */
+    protected transient var cachedValid:boolean;
     /** Cached pointer to the backing storage */
     protected transient var cachedRaw:IndexedMemoryChunk[T];
+    /** Cached local ghost region */
+    protected transient var cachedGhostRegion:Region(rank);
+
+    private final @Inline def cacheFields() {
+        cachedRaw = localHandle().data;
+        cachedGhostRegion = localHandle().ghostRegion as Region(rank);
+        x10.util.concurrent.Fences.storeStoreBarrier();
+	    cachedValid = true;
+    }
     
     /**
      * Method to acquire a pointer to the backing storage for the 
      * array's data in the current place.
      */
     protected final def raw():IndexedMemoryChunk[T] {
-        if (!cachedRawValid) {
-            cachedRaw = localHandle().data;
-            x10.util.concurrent.Fences.storeStoreBarrier();
-	    cachedRawValid = true;
+        if (!cachedValid) {
+            cacheFields();
         }
         return cachedRaw;
     }
 
     /**
-     * @return the portion of the DistArray that is stored 
-     *    locally at the current place, as an Array
+     * Method to acquire a pointer to the local region in the current place.
      */
+    public final def localRegion():Region(rank) {
+        if (!cachedValid) {
+            cacheFields();
+        }
+        return cachedGhostRegion;
+    }
+
+    /**
+     * @return the portion of the DistArray (including ghosts) that is stored 
+     *   locally at the current place, as an Array
+     */
     public def getLocalPortion():Array[T](dist.rank) {
-        val regionForHere = dist.get(here);
+        val regionForHere = localRegion();
         if (!regionForHere.rect) throw new UnsupportedOperationException(this.typeName() +".getLocalPortion(): local portion is not rectangular!");
         return new Array[T](regionForHere, raw());
     }
@@ -120,18 +166,78 @@
      */
     public static def make[T](dist:Dist) {T haszero} = new DistArray[T](dist);
 
+    /**
+     * Create a zero-initialized distributed array over the argument distribution
+     * with a BlockBlockDistGhostManagerPut. TODO remove, for testing purposes only
+     */
+    public static def make[T](dist:Dist, ghostWidth:Int, periodic:Boolean, put:Boolean) {T haszero} = new DistArray[T](dist, ghostWidth, periodic, put);
+
+    /**
+     * Create a zero-initialized distributed array over the argument distribution.
+     *
+     * @param dist the given distribution
+     * @param ghostWidth the width of the ghost region in every dimension
+     * @param periodic whether to apply periodic boundary conditions
+     * @return the newly created DistArray
+     */
+    public static def make[T](dist:Dist, ghostWidth:Int, periodic:Boolean) {T haszero} = new DistArray[T](dist, ghostWidth, periodic);
+
+     // TODO: consider making this constructor public
     def this(dist: Dist) {T haszero} : DistArray[T]{self.dist==dist} {
+        this(dist, 0, false);
+    }
+
+    def this(dist: Dist, ghostWidth:Int, periodic:Boolean) {T haszero} : DistArray[T]{self.dist==dist} {
         property(dist);
 
+        val team = getTeamOverPlaces();
         val plsInit:()=>LocalState[T] = () => {
-            val size = dist.places().contains(here) ? dist.maxOffset()+1 : 0;
-            val localRaw = IndexedMemoryChunk.allocateZeroed[T](size);
-            return new LocalState(dist, localRaw);
+            val localRegion:Region(rank);
+            val ghostManager = DistArray.getGhostManager(dist, team, ghostWidth, periodic);
+            if (ghostManager != null) {
+                localRegion = ghostManager.getGhostRegion(here) as Region(rank);
+            } else {
+                localRegion = dist(here);
+            }
+            val localRaw = IndexedMemoryChunk.allocateZeroed[T](localRegion.size());
+            return new LocalState[T](dist, localRaw, localRegion, ghostManager);
         };
 
         localHandle = PlaceLocalHandle.makeFlat[LocalState[T]](PlaceGroup.WORLD, plsInit);
     }
 
+    /**
+     * Creates a DistArray with a BlockBlockDistGhostManagerPut
+     * TODO for testing purposes only
+     */
+    def this(dist: Dist, ghostWidth:Int, periodic:Boolean, put:Boolean) {T haszero} : DistArray[T]{self.dist==dist} {
+        property(dist);
+ 
+        val team = getTeamOverPlaces();
+        val plsInit:()=>LocalState[T] = () => {
+            val localRegion:Region(rank);
+            val ghostManager:GhostManager;
+            if (dist instanceof BlockBlockDist) {
+                ghostManager = new BlockBlockDistGhostManagerPut(ghostWidth, dist as BlockBlockDist, team, periodic);
+            } else {
+                ghostManager = DistArray.getGhostManager(dist, team, ghostWidth, periodic);
+            }
+            if (ghostManager != null) {
+                localRegion = ghostManager.getGhostRegion(here) as Region(rank);
+            } else {
+                localRegion = dist(here);
+            }
+            val localRaw = IndexedMemoryChunk.allocateZeroed[T](localRegion.size());
+
+            return new LocalState[T](dist, localRaw, localRegion, ghostManager);
+        };
+
+        localHandle = PlaceLocalHandle.make[LocalState[T]](dist, plsInit);
+    }
+
+
+
+
     def this(sd:SerialData) {
       val plh:PlaceLocalHandle[LocalState[T]] = sd.data as PlaceLocalHandle[LocalState[T]];
       val d:Dist = plh().dist;
@@ -161,27 +267,50 @@
      * @return the newly created DistArray
      * @see #make[T](Dist)
      */
-    public static def make[T](dist:Dist, init:(Point(dist.rank))=>T)= new DistArray[T](dist, init);
+    public static def make[T](dist:Dist, init:(Point(dist.rank))=>T)= new DistArray[T](dist, init, 0, false);
 
+    /**
+     * Create a distributed array over the argument distribution whose elements
+     * are initialized by executing the given initializer function for each 
+     * element of the array in the place where the argument Point is mapped. 
+     * The function will be evaluated exactly once for each point
+     * in dist in an arbitrary order to compute the initial value for each array element.</p>
+     * 
+     * Within each place, it is unspecified whether the function evaluations will
+     * be done sequentially by a single activity for each point or concurrently for disjoint sets 
+     * of points by one or more child activities. 
+     * 
+     * @param dist the given distribution
+     * @param init the initializer function
+     * @param ghostWidth the width of the ghost region in every dimension
+     * @param periodic whether to apply periodic boundary conditions
+     * @return the newly created DistArray
+     * @see #make[T](Dist)
+     */
+    public static def make[T](dist:Dist, init:(Point(dist.rank))=>T, ghostWidth:Int, periodic:Boolean)= new DistArray[T](dist, init, ghostWidth, periodic);
+
     // TODO: consider making this constructor public
-    def this(dist:Dist, init:(Point(dist.rank))=>T):DistArray[T]{self.dist==dist} {
+    def this(dist:Dist, init:(Point(dist.rank))=>T, ghostWidth:Int, periodic:Boolean):DistArray[T]{self.dist==dist} {
         property(dist);
 
+        val team = getTeamOverPlaces();
         val plsInit:()=>LocalState[T] = () => {
-            val localRaw:IndexedMemoryChunk[T];
-            if (dist.places().contains(here)) {
-                localRaw = IndexedMemoryChunk.allocateUninitialized[T](dist.maxOffset()+1);
-                val reg = dist.get(here);
-                for (pt in reg) {
-                    localRaw(dist.offset(pt)) = init(pt);
-                }
+            val localRegion:Region(rank);
+            val ghostManager = DistArray.getGhostManager(dist, team, ghostWidth, periodic);
+            if (ghostManager != null) {
+                localRegion = ghostManager.getGhostRegion(here) as Region(rank);
             } else {
-                localRaw = IndexedMemoryChunk.allocateUninitialized[T](0);
+                localRegion = dist(here);
             }
-            return new LocalState(dist, localRaw);
+            val localRaw = IndexedMemoryChunk.allocateUninitialized[T](localRegion.size());
+            val reg = dist(here);
+            for (pt in reg) {
+                localRaw(localRegion.indexOf(pt)) = init(pt);
+            }
+            return new LocalState(dist, localRaw, localRegion, ghostManager);
         };
 
-        localHandle = PlaceLocalHandle.make[LocalState[T]](PlaceGroup.WORLD, plsInit);
+        localHandle = PlaceLocalHandle.make[LocalState[T]](dist, plsInit);
     }
 
 
@@ -194,24 +323,41 @@
      * @return the newly created DistArray
      * @see #make[T](Dist)
      */
-    public static def make[T](dist:Dist, init:T)= new DistArray[T](dist, init);
+    public static def make[T](dist:Dist, init:T)= new DistArray[T](dist, init, 0, false);
 
+    /**
+     * Create a distributed array over the argument distribution whose elements
+     * are initialized to the given initial value.
+     *
+     * @param dist the given distribution
+     * @param init the initial value
+     * @param ghostWidth the width of the ghost region in every dimension
+     * @param periodic whether to apply periodic boundary conditions
+     * @return the newly created DistArray
+     * @see #make[T](Dist)
+     */
+    public static def make[T](dist:Dist, init:T, ghostWidth:Int, periodic:Boolean)= new DistArray[T](dist, init, ghostWidth, periodic);
+
+
     // TODO: consider making this constructor public
-    def this(dist:Dist, init:T):DistArray[T]{self.dist==dist} {
+    def this(dist:Dist, init:T, ghostWidth:Int, periodic:Boolean):DistArray[T]{self.dist==dist} {
         property(dist);
 
+        val team = getTeamOverPlaces();
         val plsInit:()=>LocalState[T] = () => {
-            val localRaw:IndexedMemoryChunk[T];
-            if (dist.places().contains(here)) {
-                localRaw = IndexedMemoryChunk.allocateUninitialized[T](dist.maxOffset()+1);
-                val reg = dist.get(here);
-                for (pt in reg) {
-                    localRaw(dist.offset(pt)) = init;
-                }
+            val localRegion:Region(rank);
+            val ghostManager = DistArray.getGhostManager(dist, team, ghostWidth, periodic);
+            if (ghostManager != null) {
+                localRegion = ghostManager.getGhostRegion(here) as Region(rank);
             } else {
-                localRaw = IndexedMemoryChunk.allocateUninitialized[T](0);
+                localRegion = dist(here);
             }
-            return new LocalState(dist, localRaw);
+            val localRaw = IndexedMemoryChunk.allocateUninitialized[T](localRegion.size());
+            val reg = dist(here);
+             for (pt in reg) {
+                localRaw(localRegion.indexOf(pt)) = init;
+             }
+            return new LocalState(dist, localRaw, localRegion, ghostManager);
         };
 
         localHandle = PlaceLocalHandle.makeFlat[LocalState[T]](PlaceGroup.WORLD, plsInit);
@@ -222,14 +368,14 @@
      * as the argument DistArray using a different distribution.</p>
      * 
      * An unchecked invariant for this to be correct is that for every 
-     * point p in d, <code>d.offset(p) == a.dist.offset(p)</code>.  
+     * point p in d, <code>d(here).indexOf(p) == a.dist(here).indexOf(p)</code>.  
      * This invariant is too expensive to be checked dynamically, so it simply must
      * be respected by the DistArray code that calls this constructor.
      */
     protected def this(a:DistArray[T], d:Dist):DistArray[T]{self.dist==d} {
         property(d);
 
-        val plsInit:()=>LocalState[T] = ()=> new LocalState(d, a.localHandle().data);
+        val plsInit:()=>LocalState[T] = ()=> new LocalState(d, a.localHandle().data, a.localHandle().ghostRegion, a.localHandle().ghostManager);
         localHandle = PlaceLocalHandle.makeFlat[LocalState[T]](PlaceGroup.WORLD, plsInit);
     }
 
@@ -256,7 +402,8 @@
      * @see #set(T, Point)
      */
     public final operator this(pt:Point(rank)): T {
-        val offset = dist.offset(pt);
+        val offset = localRegion().indexOf(pt);
+        if (CompilerFlags.checkPlace() && offset == -1) raisePlaceError(pt);
         return raw()(offset);
     }
 
@@ -273,7 +420,8 @@
      * @see #set(T, Int)
      */
     public final operator this(i0:int){rank==1}: T {
-        val offset = dist.offset(i0);
+        val offset = localRegion().indexOf(i0);
+        if (CompilerFlags.checkPlace() && offset == -1) raisePlaceError(i0);
         return raw()(offset);
     }
 
@@ -291,7 +439,8 @@
      * @see #set(T, Int, Int)
      */
     public final operator this(i0:int, i1:int){rank==2}: T {
-        val offset = dist.offset(i0, i1);
+        val offset = localRegion().indexOf(i0, i1);
+        if (CompilerFlags.checkPlace() && offset == -1) raisePlaceError(i0, i1);
         return raw()(offset);
     }
 
@@ -310,7 +459,8 @@
      * @see #set(T, Int, Int, Int)
      */
     public final operator this(i0:int, i1:int, i2:int){rank==3}: T {
-        val offset = dist.offset(i0, i1, i2);
+        val offset = localRegion().indexOf(i0, i1, i2);
+        if (CompilerFlags.checkPlace() && offset == -1) raisePlaceError(i0, i1, i2);
         return raw()(offset);
     }
 
@@ -330,12 +480,66 @@
      * @see #set(T, Int, Int, Int, Int)
      */
     public final operator this(i0:int, i1:int, i2:int, i3:int){rank==4}: T {
-        val offset = dist.offset(i0, i1, i2, i3);
+        val offset = localRegion().indexOf(i0, i1, i2, i3);
+        if (CompilerFlags.checkPlace() && offset == -1) raisePlaceError(i0, i1, i2, i3);
         return raw()(offset);
     }
 
+    /**
+     * Return the element of this array corresponding to the given point,
+     * wrapped for periodic boundary conditions.
+     * The rank of the given point has to be the same as the rank of this array.
+     * If the distribution does not map the given Point to the current place,
+     * then a BadPlaceException will be raised.
+     * 
+     * @param pt the given point
+     * @return the element of this array corresponding to the given point.
+     * @see #operator(Int)
+     * @see #set(T, Point)
+     */
+    public final def getPeriodic(pt:Point(rank)): T {
+        val l = localRegion();
+        val actualPt:Point(rank);
+        if (l.contains(pt)) {
+            actualPt = pt;
+        } else {
+            actualPt = PeriodicBoundaryConditions.wrapPeriodic(pt, region());
+        }
+        val offset = l.indexOf(actualPt);
+        if (CompilerFlags.checkPlace() && offset == -1) raisePlaceError(pt);
+        return raw()(offset);
+    }
 
     /**
+     * Return the element of this three-dimensional array according to the given
+     * indices, wrapped for periodic boundary conditions.
+     * The rank of the given point has to be the same as the rank of this array.
+     * If the distribution does not map the given Point to the current place,
+     * then a BadPlaceException will be raised.
+     * 
+     * @param pt the given point
+     * @return the element of this array corresponding to the given point.
+     * @see #operator(Int)
+     * @see #set(T, Point)
+     */
+    public final def getPeriodic(i0:int, i1:int, i2:int){rank==3}: T {
+        val l = localRegion();
+        val offset:Int;
+        if (l.contains(i0,i1,i2)) {
+            offset = l.indexOf(i0,i1,i2);
+        } else {
+            val r = region();
+            val a0 = PeriodicBoundaryConditions.getPeriodicIndex(i0, r.min(0), r.max(0));
+            val a1 = PeriodicBoundaryConditions.getPeriodicIndex(i1, r.min(1), r.max(1));
+            val a2 = PeriodicBoundaryConditions.getPeriodicIndex(i2, r.min(2), r.max(2));
+            offset = l.indexOf(a0,a1,a2);
+        }
+        if (CompilerFlags.checkPlace() && offset == -1) raisePlaceError(i0, i1, i2);
+        return raw()(offset);
+    }
+
+
+    /**
      * Set the element of this array corresponding to the given point to the given value.
      * Return the new value of the element.
      * The rank of the given point has to be the same as the rank of this array.
@@ -349,7 +553,8 @@
      * @see #set(T, Int)
      */    
     public final operator this(pt: Point(rank))=(v: T): T {
-        val offset = dist.offset(pt);
+        if (CompilerFlags.checkPlace() && dist(pt) != here) raisePlaceError(pt);
+        val offset = localRegion().indexOf(pt);
         raw()(offset) = v;
         return v;
     }
@@ -369,7 +574,8 @@
      * @see #set(T, Point)
      */    
     public final operator this(i0: int)=(v: T){rank==1}: T {
-        val offset = dist.offset(i0);
+        if (CompilerFlags.checkPlace() && dist(i0) != here) raisePlaceError(i0);
+        val offset = localRegion().indexOf(i0);
         raw()(offset) = v;
         return v;
     }
@@ -390,7 +596,8 @@
      * @see #set(T, Point)
      */
     public final operator this(i0: int, i1: int)=(v: T){rank==2}: T {
-        val offset = dist.offset(i0, i1);
+        if (CompilerFlags.checkPlace() && dist(i0, i1) != here) raisePlaceError(i0, i1);
+        val offset = localRegion().indexOf(i0, i1);
         raw()(offset) = v;
         return v;
     }
@@ -412,7 +619,8 @@
      * @see #set(T, Point)
      */
     public final operator this(i0: int, i1: int, i2: int)=(v: T){rank==3}: T {
-        val offset = dist.offset(i0,i1,i2);
+        if (CompilerFlags.checkPlace() && dist(i0, i1, i2) != here) raisePlaceError(i0, i1, i2);
+        val offset = localRegion().indexOf(i0,i1,i2);
         raw()(offset) = v;
         return v;
     }
@@ -435,25 +643,54 @@
      * @see #set(T, Point)
      */
     public final operator this(i0: int, i1: int, i2: int, i3: int)=(v: T){rank==4}: T {
-        val offset = dist.offset(i0,i1,i2,i3);
+        if (CompilerFlags.checkPlace() && dist(i0, i1, i2, i3) != here) raisePlaceError(i0, i1, i2, i3);
+        val offset = localRegion().indexOf(i0,i1,i2,i3);
         raw()(offset) = v;
         return v;
     }
 
+    /**
+     * Set the element of this array corresponding to the given point (wrapped
+     * for periodic boundary conditions) to the given value.
+     * Return the new value of the element.
+     * The rank of the given point has to be the same as the rank of this array.
+     * If the distribution does not map the specified index to the current place,
+     * then a BadPlaceException will be raised.
+     * 
+     * @param v the given value
+     * @param pt the given point
+     * @return the new value of the element of this array corresponding to the given point.
+     * @see #operator(Point)
+     * @see #set(T, Int)
+     */    
+    public final def setPeriodic(pt: Point(rank), v:T): T {
+        val l = localRegion();
+        val actualPt:Point(rank);
+        if (l.contains(pt)) {
+            actualPt = pt;
+        } else {
+            actualPt = PeriodicBoundaryConditions.wrapPeriodic(pt, region());
+        }
+        if (CompilerFlags.checkPlace() && dist(actualPt) != here) raisePlaceError(pt);
+        val offset = l.indexOf(actualPt);
+        raw()(offset) = v;
+        return v;
+    }
+
     /*
      * restriction view
      */
 
     /**
-     * Return a DistArray that access the same backing storage
+     * Return a DistArray that accesses the same backing storage
      * as this array, but only over the Points in the argument
-     * distribtion.</p>
+     * distribution.</p>
      * 
      * For this operation to be semantically sound, it should
      * be the case that for every point p in d, 
-     * <code>this.dist.offset(p) == d.offset</code>.
+     * <code>this.dist(here).indexOf(p) == d(here).indexOf(p)</code>.
      * This invariant is not statically or dynamically checked;
-     * but must be ensured by the caller's of this API. 
+     * but must be ensured by the callers of this API. 
      * 
      * @param d the Dist to use as the restriction
      */
@@ -519,9 +756,10 @@
         finish for (where in dist.places()) {
             at (where) async {
                 val imc = raw();
-                val reg = dist.get(here);
+                val reg = dist(here);
+                val localRegion = localRegion();
                 for (pt in reg) {
-                    imc(dist.offset(pt)) = v;
+                    imc(localRegion.indexOf(pt)) = v;
                 }
             }
         }
@@ -538,19 +776,16 @@
      */
     public final def map[U](op:(T)=>U):DistArray[U](this.dist) {
         val plh = PlaceLocalHandle.make[LocalState[U]](PlaceGroup.WORLD, ()=> {
-            val newImc:IndexedMemoryChunk[U];
-            if (dist.places().contains(here)) {
-                val srcImc = raw();
-                newImc = IndexedMemoryChunk.allocateUninitialized[U](dist.maxOffset()+1);
-                val reg = dist.get(here);
-                for (pt in reg) {
-                    val offset = dist.offset(pt);
-                    newImc(offset) = op(srcImc(offset));
-                }
-            } else {
-                newImc = IndexedMemoryChunk.allocateUninitialized[U](0);
+            val srcImc = raw();
+            val localRegion = localRegion();
+            val newImc = IndexedMemoryChunk.allocateUninitialized[U](localRegion.size());
+            val reg = dist(here);
+            for (pt in reg) {
+                val offset = localRegion.indexOf(pt);
+                newImc(offset) = op(srcImc(offset));
             }
-            return new LocalState[U](dist, newImc);
+            val ghostManager = localHandle().ghostManager;
+            return new LocalState[U](dist, newImc, localRegion, ghostManager);
         });
         return new DistArray[U](dist, plh);                       
     }
@@ -569,11 +804,12 @@
         finish {
             for (where in dist.places()) {
                 at(where) async {
-                    val reg = dist.get(here);
+                    val reg = dist(here);
+                    val localRegion = localRegion();
                     val srcImc = raw();
                     val dstImc = dst.raw();
                     for (pt in reg) {
-                        val offset = dist.offset(pt);
+                        val offset = localRegion.indexOf(pt);
                         dstImc(offset) = op(srcImc(offset));
                     }
                 }
@@ -598,12 +834,13 @@
         finish {
             for (where in dist.places()) {
                 at(where) async {
-                    val reg = dist.get(here);
+                    val reg = dist(here);
                     val freg = reg && filter;
+                    val localRegion = localRegion();
                     val srcImc = raw();
                     val dstImc = dst.raw();
                     for (pt in freg) {
-                        val offset = dist.offset(pt);
+                        val offset = localRegion.indexOf(pt);
                         dstImc(offset) = op(srcImc(offset));
                     }
                 }
@@ -624,20 +861,17 @@
      */
     public final def map[S,U](src:DistArray[U](this.dist), op:(T,U)=>S):DistArray[S](dist) {
         val plh = PlaceLocalHandle.make[LocalState[S]](PlaceGroup.WORLD, ()=> {
-            val newImc:IndexedMemoryChunk[S];
-            if (dist.places().contains(here)) {
-                val src1Imc = raw();
-                val src2Imc = src.raw();
-                newImc = IndexedMemoryChunk.allocateUninitialized[S](dist.maxOffset()+1);
-                val reg = dist.get(here);
-                for (pt in reg) {
-                    val offset = dist.offset(pt);
-                    newImc(offset) = op(src1Imc(offset), src2Imc(offset));
-                }
-            } else {
-                newImc = IndexedMemoryChunk.allocateUninitialized[S](0);
+            val src1Imc = raw();
+            val src2Imc = src.raw();
+            val reg = dist.get(here);
+            val localRegion = localRegion();
+            val newImc = IndexedMemoryChunk.allocateUninitialized[S](localRegion.size());
+            for (pt in reg) {
+                val offset = localRegion.indexOf(pt);
+                newImc(offset) = op(src1Imc(offset), src2Imc(offset));
             }
-            return new LocalState[S](dist, newImc);
+            val ghostManager = localHandle().ghostManager;
+            return new LocalState[S](dist, newImc, localRegion, ghostManager);
         });
         return new DistArray[S](dist, plh);                       
     }
@@ -657,12 +891,13 @@
         finish {
             for (where in dist.places()) {
                 at(where) async {
-                    val reg = dist.get(here);
+                    val reg = dist(here);
+                    val localRegion = localRegion();
                     val src1Imc = raw();
                     val src2Imc = src.raw();
                     val dstImc = dst.raw();
                     for (pt in reg) {
-                        val offset = dist.offset(pt);
+                        val offset = localRegion.indexOf(pt);
                         dstImc(offset) = op(src1Imc(offset), src2Imc(offset));
                     }
                 }
@@ -687,13 +922,14 @@
         finish {
             for (where in dist.places()) {
                 at(where) async {
-                    val reg = dist.get(here);
+                    val reg = dist(here);
+                    val localRegion = localRegion();
                     val freg = reg && filter;
                     val src1Imc = raw();
                     val src2Imc = src.raw();
                     val dstImc = dst.raw();
                     for (pt in freg) {
-                        val offset = dist.offset(pt);
+                        val offset = localRegion.indexOf(pt);
                         dstImc(offset) = op(src1Imc(offset), src2Imc(offset));
                     }
                 }
@@ -737,11 +973,12 @@
         val result = finish(reducer) {
             for (where in dist.places()) {
                 at (where) async {
-                    val reg = dist.get(here);
+                    val reg = dist(here);
+                    val localRegion = localRegion();
                     var localRes:U = unit;
                     val imc = raw();
                     for (pt in reg) {
-                       localRes = lop(localRes, imc(dist.offset(pt)));
+                       localRes = lop(localRes, imc(localRegion.indexOf(pt)));
                     }
                     offer(localRes);
                 }
@@ -751,7 +988,222 @@
         return result;
     }
 
+    /**
+     * Updates ghost data for every place in this DistArray.
+     * This includes synchronization before and after the update.
+     */
+    public def updateGhosts() {
+        if (localHandle().ghostManager != null) {
+            finish ateach(place in Dist.makeUnique(dist.places())) {
+                val ghostManager = localHandle().ghostManager;
+                ghostManager.sendGhosts(this);
+                ghostManager.waitOnGhosts();
+            }
+        }
+    }
 
+    public def sendGhosts() {
+        val ghostManager = localHandle().ghostManager;
+        if (ghostManager != null) {
+            ghostManager.sendGhosts(this);
+        }
+    }
+
+    public def waitOnGhosts() {
+        val ghostManager = localHandle().ghostManager;
+        if (ghostManager != null) {
+            ghostManager.waitOnGhosts();
+        }
+    }
+
+    /**
+     * Sends one edge of ghost data to neighboring places in
+     * the direction of <code>shift</code>.
+     * @param reg the region of data held at this place that should be sent to neighboring places
+     * @param shiftDim the dimension along which the data should be sent
+     * @param forward whether to send in the forward or backwards direction
+     * @param notify whether to set the [...]GhostReceived flags to notify at the destination place
+     */
+    public def sendToNeighbor(r:Region{rect}, neighborId:Int, neighborReg:Region{rank==r.rank,rect}, shiftDim:Int, forward:Boolean, phase:Byte, periodic:Boolean):void {
+        val neighbor = Place(neighborId);
+        if (rank==3) {
+            sendToNeighbor3(r as Region(3){rect}, neighbor, neighborReg as Region(3){rect}, shiftDim, forward, phase, periodic);
+        } else {
+            val reg = r as Region(rank){rect};
+            var neighborSent:Boolean = false;
+            val sourcePlace = here;
+            if (neighbor != here) {
+                val g = localRegion();
+                val localRaw = raw();
+                val overlap = (neighborReg && reg) as Region(rank){rect};
+                if (! overlap.isEmpty()) {
+                    neighborSent = true;
+                    val neighborPortion = new Array[T](overlap, (p:Point(rank)) => localRaw(g.indexOf(p)) );
+                    @Uncounted at(neighbor) async {
+                        val ghostManager = localHandle().ghostManager;
+                        if (!Runtime.STATIC_THREADS) {
+                            //Console.OUT.println("waiting at " + here + " to deliver ghosts from " + sourcePlace);
+                            when (ghostManager.currentPhase() == phase);
+                        }
+                        val local2 = getLocalPortion();
+                        val local2Reg = local2.region;
+                        val local2Raw = local2.raw();
+                        for (p in overlap) {
+                            local2Raw(local2Reg.indexOf(p)) = neighborPortion(p);
+                        }
+                        ghostManager.setNeighborReceived(sourcePlace);
+                        //Console.OUT.println("setNeighborReceived at " + here + " from " + sourcePlace);
+                    }
+                }
+            }
+            if (!neighborSent && periodic) {
+                // there may still be a 'neighbor' with PBC
+                val g = localRegion();
+                val localRaw = raw();
+                val wrap = (region.max(shiftDim)-region.min(shiftDim)+1);
+                val wrapShift = Point.make(rank, (i:Int) => i==shiftDim ? (forward?-wrap:wrap) : 0);
+                val wrapReg = reg + wrapShift;
+                val overlap = (neighborReg && wrapReg) as Region(rank){rect};
+                if (! overlap.isEmpty()) {
+                    neighborSent = true;
+                    val wrapOverlap = (overlap - wrapShift) as Region(rank){rect};
+                    val neighborPortion = new Array[T](wrapOverlap, (p:Point(rank)) => localRaw(g.indexOf(p)) );
+                    @Uncounted at(neighbor) async {
+                        val ghostManager = localHandle().ghostManager;
+                        if (!Runtime.STATIC_THREADS) {
+                            //Console.OUT.println("waiting at " + here + " to deliver ghosts from " + sourcePlace + " phase " + phase + " periodic");
+                            when (ghostManager.currentPhase() == phase);
+                        }
+                        val local2 = getLocalPortion();
+                        val local2Reg = local2.region;
+                        val local2Raw = local2.raw();
+                        for (p in overlap) {
+                            val offset = local2Reg.indexOf(p);
+                            local2Raw(offset) = neighborPortion(p - wrapShift);
+                        }
+                        ghostManager.setNeighborReceived(sourcePlace);
+                        //Console.OUT.println("setNeighborReceived at " + here + " from " + sourcePlace + " phase " + phase + " periodic");
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Sends one edge of ghost data to neighboring places in
+     * the direction of <code>shift</code> for a rank-3 region.
+     * This is a hack to demonstrate the performance that would be possible with inlined Points.
+     * @param reg the region of data held at this place that should be sent to neighboring places
+     * @param shiftDim the dimension along which the data should be sent
+     * @param forward whether to send in the forward or backwards direction
+     * @param notify whether to set the [...]GhostReceived flags to notify at the destination place
+     */
+    private final def sendToNeighbor3(reg:Region(3){rect}, neighbor:Place, neighborReg:Region(3){rect}, shiftDim:Int, forward:Boolean, phase:Byte, periodic:Boolean) {
+        var neighborSent:Boolean = false;
+        val sourcePlace = here;
+        if (neighbor != here) {
+            val overlap = (neighborReg && reg) as Region(3){rect};
+            if (! overlap.isEmpty()) {
+                neighborSent = true;
+                val localPortion = getLocalPortion() as Array[T](3){rect};
+                val neighborPortion = localPortion.getPatch(overlap);
+                @Uncounted at(neighbor) async {
+                    val ghostManager = localHandle().ghostManager;
+                    if (!Runtime.STATIC_THREADS) {
+                        //Console.OUT.println("waiting at " + here + " to deliver ghosts from " + sourcePlace + " phase " + phase);
+                        when (ghostManager.currentPhase() == phase);
+                    }
+                    val local2 = getLocalPortion() as Array[T](3){rect};
+                    local2.copy(neighborPortion, neighborPortion.region);
+                    ghostManager.setNeighborReceived(sourcePlace);
+                    //Console.OUT.println("setNeighborReceived at " + here + " from " + sourcePlace);
+                }
+            }
+        }
+        if (!neighborSent && periodic) {
+            // there may still be a 'neighbor' with PBC
+            val wrap = (region.max(shiftDim)-region.min(shiftDim)+1);
+            val wrapI = shiftDim == 0 ? (forward?-wrap:wrap) : 0;
+            val wrapJ = shiftDim == 1 ? (forward?-wrap:wrap) : 0;
+            val wrapK = shiftDim == 2 ? (forward?-wrap:wrap) : 0;
+            val wrapShift = Point.make(wrapI, wrapJ, wrapK);
+            val wrapReg = (reg + wrapShift) as Region(3){rect};
+            val neighborWrapIncluded = neighborReg && wrapReg;
+            if (!neighborWrapIncluded.isEmpty()) {
+                val overlap = (neighborReg && wrapReg) as Region(3){rect};
+                if (! overlap.isEmpty()) {
+                    neighborSent = true;
+                    val wrapOverlap = (overlap - wrapShift) as Region(3){rect};
+                    val localPortion = getLocalPortion() as Array[T](3){rect};
+                    val neighborPortionWrap = localPortion.getPatch(wrapOverlap);
+                    // need to subtract wrap before sending to neighbor
+                    val neighborPortion = new Array[T](overlap, neighborPortionWrap.raw());
+                    @Uncounted at(neighbor) async {
+                        val ghostManager = localHandle().ghostManager;
+                        if (!Runtime.STATIC_THREADS) {
+                            //Console.OUT.println("waiting at " + here + " to deliver ghosts from " + sourcePlace + " phase " + phase + " periodic");
+                            when (ghostManager.currentPhase() == phase);
+                        }
+                        val local2 = getLocalPortion() as Array[T](3){rect};
+                        local2.copy(neighborPortion, neighborPortion.region);
+                        ghostManager.setNeighborReceived(sourcePlace);
+                        //Console.OUT.println("setNeighborReceived at " + here + " from " + sourcePlace + " periodic");
+                    }
+                }
+            }
+        }
+    }
+
+    public def putOverlap(overlap:Region{rect}, neighborId:Int, phase:Byte) {
+        val neighbor = Place(neighborId);
+        if (rank==3) {
+            putOverlap3(overlap as Region(3){rect}, neighbor, phase);
+        } else {
+            if (!overlap.isEmpty()) {
+                val sourcePlace = here;
+                val localRaw = raw();
+                val g = localRegion();
+                val neighborPortion = new Array[T](overlap, (p:Point(overlap.rank)) => localRaw(g.indexOf(p)) );
+                @Uncounted at(neighbor) async {
+                    val ghostManager = localHandle().ghostManager;
+                    if (!Runtime.STATIC_THREADS) {
+                        //Console.OUT.println("waiting at " + here + " to put ghosts from " + sourcePlace + " phase " + phase + " periodic");
+                        when (ghostManager.currentPhase() == phase);
+                    }
+                    val local2 = getLocalPortion();
+                    val local2Reg = local2.region;
+                    val local2Raw = local2.raw();
+                    for (p in overlap) {
+                        local2Raw(local2Reg.indexOf(p)) = neighborPortion(p);
+                    }
+                    //Console.OUT.println("setting neighbor received " + sourcePlace + " at " + here);
+                    ghostManager.setNeighborReceived(sourcePlace);
+                }
+            }
+        }
+    }
+
+    private def putOverlap3(overlap:Region(3){rect}, place2:Place, phase:Byte) {
+        if (!overlap.isEmpty()) {
+            val sourcePlace = here;
+            val localRaw = raw();
+            val g = localRegion();
+            val localPortion = getLocalPortion() as Array[T](3){rect};
+            val neighborPortion = localPortion.getPatch(overlap);
+            @Uncounted at(place2) async {
+                val ghostManager = localHandle().ghostManager;
+                if (!Runtime.STATIC_THREADS) {
+                    //Console.OUT.println("waiting at " + here + " to put ghosts from " + sourcePlace + " phase " + phase);
+                    when (ghostManager.currentPhase() == phase);
+                }
+                val local2 = getLocalPortion() as Array[T](3){rect};
+                local2.copy(neighborPortion, neighborPortion.region);
+                //Console.OUT.println("setting neighbor received " + sourcePlace + " at " + here);
+                ghostManager.setNeighborReceived(sourcePlace);
+            }
+        }
+    }
+
     public def toString(): String {
         return "DistArray(" + dist + ")";
     }
@@ -763,6 +1215,23 @@
      * @see x10.lang.Iterable[T]#iterator()
      */
     public def iterator(): Iterator[Point(rank)] = region.iterator() as Iterator[Point(rank)];
+
+    protected static @NoInline @NoReturn def raisePlaceError(i0:int) {
+        throw new BadPlaceException("point (" + i0 + ") not defined at " + here);
+    }    
+    protected static @NoInline @NoReturn def raisePlaceError(i0:int, i1:int) {
+        throw new BadPlaceException("point (" + i0 + ", "+i1+") not defined at " + here);
+    }    
+    protected static @NoInline @NoReturn def raisePlaceError(i0:int, i1:int, i2:int) {
+        throw new BadPlaceException("point (" + i0 + ", "+i1+", "+i2+") not defined at " + here);
+    }    
+    protected static @NoInline @NoReturn def raisePlaceError(i0:int, i1:int, i2:int, i3:int) {
+        throw new BadPlaceException("point (" + i0 + ", "+i1+", "+i2+", "+i3+") not defined at " + here);
+    }    
+    protected static @NoInline @NoReturn def raisePlaceError(pt:Point) {
+        throw new BadPlaceException("point " + pt + " not defined at " + here);
+    }  
+
 }
 public type DistArray[T](r:Int) = DistArray[T]{self.rank==r};
 public type DistArray[T](r:Region) = DistArray[T]{self.region==r};
Index: x10.runtime/src-x10/x10/array/Dist.x10
===================================================================
--- x10.runtime/src-x10/x10/array/Dist.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/Dist.x10	(working copy)
@@ -14,6 +14,8 @@
 import x10.compiler.NoInline;
 import x10.compiler.NoReturn;
 
+import x10.util.Team;
+
 /**
  * A distributution supports distributed arrays by providing a mapping
  * from Points to Places.  Equivalently, a distribution may be defined
@@ -129,10 +131,39 @@
      * @return a "block,block" distribution over r.
      */
     public static def makeBlockBlock(r:Region, axis0:int, axis1:int):Dist(r) {
-        return new BlockBlockDist(r, axis0, axis1, PlaceGroup.WORLD);//) as Dist(r); // TODO: should not need this cast
+        return Dist.makeBlockBlock(r, axis0, axis1, PlaceGroup.WORLD);
     }
 
     /**
+     * Creates a block, block distribution across all places in pg.
+     * The coordinates are split along axis0 into M divisions such that M is the minimum of:
+     *   - 2^q where q is the next integer above log2(P) / 2
+     *   - the length of axis0
+     * and split along axis1 into N divisions such that M*(N-1) <= P <= M*N.
+     * Thus there are M*N blocks of size (axis0/M, axis1/N).
+     * The blocks are not necessarily of integer size in either dimension.
+     * Places 0..(M*N-P) are each assigned two such blocks, contiguous in axis0.
+     * The remaining places are assigned a single block.
+     * Block min and max coordinates are rounded to create subregions for each place,
+     * e.g. a block [1.0..1.5,2.25..2.75] is rounded to a subregion [1..2,2..2].
+     * If there are less than 4 places in pg, a simpler BlockDist is returned.
+     * @param r the given region
+     * @param axis0 the first dimension to block over
+     * @param axis1 the second dimension to block over
+     * @return a "block,block" distribution over r.
+     * @param pg the PlaceGroup over which to distribute the region
+     * @return a "block,block" distribution over r, over the places in pg.
+     */
+    public static def makeBlockBlock(r:Region, axis0:int, axis1:int, pg:PlaceGroup):Dist(r) {
+        if (pg.numPlaces() < 4) {
+            // BlockDist is more efficient
+            return new BlockDist(r, axis0, pg);
+        } else {
+            return new BlockBlockDist(r, axis0, axis1, pg);
+        }
+    }
+
+    /**
      * Create a distribution over the specified region that varies in
      * place only along the 0-th axis. It divides the coordinates
      * along the 0-th axis into Place.MAX_PLACES blocks, and assigns
@@ -340,93 +371,6 @@
     public operator this(i0:int, i1:int, i2:int, i3:int){rank==4}:Place = this(Point.make(i0,i1,i2,i3));
 
 
-
-    /**
-     * Return the offset in linearized place-local storage of the given point.
-     * Throw a BadPlaceException if the given point is not mapped to 
-     * the current place.  Primarily intended to be used by the DistArray implementation,
-     * but may be useful for other data structures as well that need to associate 
-     * Points in a Distribution with a dense, zero-based numbering.
-     *
-     * @param pt the given point
-     * @return the storage offset assigned to pt by this distribution
-     */
-    abstract public def offset(pt:Point(rank)):int;
-
-    /**
-     * Return the offset in linearized place-local storage of the point [i0]
-     * Throw a BadPlaceException if the given point is not mapped to 
-     * the current place.  Primarily intended to be used by the DistArray implementation,
-     * but may be useful for other data structures as well that need to associate 
-     * Points in a Distribution with a dense, zero-based numbering.
-     *
-     * Only applies to one-dimensional distributions.
-     *
-     * @param i0 the given index in the first dimension
-     * @return the storage offset assigned to [i0] by this distribution
-     * @see #offset(Point)
-     */
-    public def offset(i0:int){rank==1}:int = offset(Point.make(i0));
-
-    /**
-     * Return the offset in linearized place-local storage of the point [i0,i1].
-     * Throw a BadPlaceException if the given point is not mapped to 
-     * the current place.  Primarily intended to be used by the DistArray implementation,
-     * but may be useful for other data structures as well that need to associate 
-     * Points in a Distribution with a dense, zero-based numbering.
-     *
-     * Only applies to two-dimensional distributions.
-     *
-     * @param i0 the given index in the first dimension
-     * @param i1 the given index in the second dimension
-     * @return the storage offset assigned to [i0,i1] by this distribution
-     * @see #offset(Point)
-     */
-    public def offset(i0:int, i1:int){rank==2}:int = offset(Point.make(i0, i1));
-
-    /**
-     * Return the offset in linearized place-local storage of the point [i0,i1,i2].
-     * Throw a BadPlaceException if the given point is not mapped to 
-     * the current place.  Primarily intended to be used by the DistArray implementation,
-     * but may be useful for other data structures as well that need to associate 
-     * Points in a Distribution with a dense, zero-based numbering.
-     *
-     * Only applies to three-dimensional distributions.
-     *
-     * @param i0 the given index in the first dimension
-     * @param i1 the given index in the second dimension
-     * @param i2 the given index in the third dimension
-     * @return the storage offset assigned to [i0,i1,i2] by this distribution
-     * @see #offset(Point)
-     */
-    public def offset(i0:int, i1:int, i2:int){rank==3}:int = offset(Point.make(i0, i1, i2));
-
-    /**
-     * Return the offset in linearized place-local storage of the point [i0,i1,i2,i3].
-     * Throw a BadPlaceException if the given point is not mapped to 
-     * the current place.  Primarily intended to be used by the DistArray implementation,
-     * but may be useful for other data structures as well that need to associate 
-     * Points in a Distribution with a dense, zero-based numbering.
-     *
-     * Only applies to four-dimensional distributions.
-     *
-     * @param i0 the given index in the first dimension
-     * @param i1 the given index in the second dimension
-     * @param i2 the given index in the third dimension
-     * @param i3 the given index in the fourth dimension
-     * @return the storage offset assigned to [i0,i1,i2,i3] by this distribution
-     * @see #offset(Point)
-     */
-    public def offset(i0:int, i1:int, i2:int, i3:int){rank==4}:int = offset(Point.make(i0,i1,i2,i3));
-
-    /**
-     * @return the maximum value returned by the offset method for
-     *         the current place for any possible argument Point
-     * @see #offset(Point)
-     */
-    public abstract def maxOffset():int;
-
-
     //
     //
     //
@@ -651,6 +595,17 @@
 */
 
 
+    /** 
+     * @param ghostWidth the width of the ghost region in elements
+     * @param team the Team to use in collective operations 
+        (TODO this is a workaround for X10_STATIC_THREADS)
+     * @param periodic whether periodic boundary conditions apply
+     * @return a ghost manager for this distribution at the current place 
+     */
+    public def getLocalGhostManager(ghostWidth:Int, team:Team, periodic:Boolean):GhostManager {
+        throw new UnsupportedOperationException("" + this.typeName() + ".getLocalGhostManager()");
+    }
+
     public def toString():String {
         var s:String = "Dist(";
         var first:boolean = true;
Index: x10.runtime/src-x10/x10/array/GhostArray.x10
===================================================================
--- x10.runtime/src-x10/x10/array/GhostArray.x10	(revision 0)
+++ x10.runtime/src-x10/x10/array/GhostArray.x10	(revision 0)
@@ -0,0 +1,23 @@
+/*
+ *  This file is part of the X10 project (http://x10-lang.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  (C) Copyright Australian National University 2011.
+ */
+
+package x10.array;
+
+/**
+ * A GhostArray allows the sending of ghost array data to other places.
+ * This is an interface to DistArray, to avoid the use of generic types
+ * in the interface GhostManager.
+ */
+public interface GhostArray {
+    def getDist():Dist;
+    def sendToNeighbor(r:Region{rect}, neighborId:Int, neighborReg:Region{rank==r.rank,rect}, shiftDim:Int, forward:Boolean, phase:Byte, periodic:Boolean):void;
+    def putOverlap(overlap:Region{rect}, neighborId:Int, phase:Byte):void;
+}

Property changes on: x10.runtime/src-x10/x10/array/GhostArray.x10
___________________________________________________________________
Added: svn:mime-type
   + text/plain
Added: svn:eol-style
   + native

Index: x10.runtime/src-x10/x10/array/GhostManager.x10
===================================================================
--- x10.runtime/src-x10/x10/array/GhostManager.x10	(revision 0)
+++ x10.runtime/src-x10/x10/array/GhostManager.x10	(revision 0)
@@ -0,0 +1,76 @@
+/*
+ *  This file is part of the X10 project (http://x10-lang.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  (C) Copyright Australian National University 2011.
+ */
+
+package x10.array;
+
+/**
+ * A GhostManager manages the ghost region at a single place, including
+ * sending ghost data to other places.
+ * Intended for use in a phased computation: in each phase, ghost data are
+ * updated at all places, then used at all places.
+ * However, synchronization is local between neighboring places, rather than
+ * global between all places.
+ */
+public abstract class GhostManager {
+    /**
+     * The width of the "ghost" region for which each place should
+     * hold a copy of data stored at neighboring places.
+     */
+    public val ghostWidth:Int;
+
+    /**
+     * The current phase of the computation with regard to ghost cell updates.
+     * Places are assumed to progress together; in even phases, ghost cells are
+     * used; in odd phases, ghost cells are updated.  No place may start phase 
+     * P+2 before neighboring places have completed phase P.
+     */
+    protected var currentPhase:Byte;
+
+    public def this(ghostWidth:Int) {
+        this.ghostWidth = ghostWidth;
+        this.currentPhase = 0;
+    }
+
+    public final def currentPhase():Byte {
+        return currentPhase;
+    }
+
+    /** @return the ghost region at the given place */
+    public abstract def getGhostRegion(place:Place):Region;
+    public abstract def setNeighborReceived(place:Place):void;
+    public abstract def allNeighborsReceived():Boolean;
+    public abstract def resetNeighborsReceived():void;
+    public abstract def sendGhosts(array:GhostArray):void;
+
+    /** 
+     * Wait for all ghosts to be received and then return.
+     * Used to switch ghost manager phase from sending to using ghost data.
+     */
+    public def waitOnGhosts() {
+        //Console.OUT.println("waitOnGhosts() - phase " + currentPhase + " at " + here);
+        when (allNeighborsReceived()) {
+            currentPhase++;
+            resetNeighborsReceived();
+        }
+        //Console.OUT.println("waitOnGhosts() - progressed to phase " + currentPhase + " at " + here);
+    }
+
+    /**
+     * Prepare to send ghosts to other places.
+     * Used to switch ghost manager phase from using to sending ghost data.
+     */
+    public atomic def prepareToSendGhosts() {
+        currentPhase++;
+    }
+}
+
+
+

Property changes on: x10.runtime/src-x10/x10/array/GhostManager.x10
___________________________________________________________________
Added: svn:mime-type
   + text/plain
Added: svn:eol-style
   + native

Index: x10.runtime/src-x10/x10/array/GhostNeighborFlag.x10
===================================================================
--- x10.runtime/src-x10/x10/array/GhostNeighborFlag.x10	(revision 0)
+++ x10.runtime/src-x10/x10/array/GhostNeighborFlag.x10	(revision 0)
@@ -0,0 +1,28 @@
+/*
+ *  This file is part of the X10 project (http://x10-lang.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  (C) Copyright Australian National University 2011.
+ */
+
+package x10.array;
+
+import x10.compiler.Mutable;
+
+/**
+ * A GhostNeighborFlag holds the status of a neighbor place for a GhostManager.
+ * TODO should be mutable struct
+ */
+class GhostNeighborFlag {
+    /** The neighbor place ID.*/
+    public val place:Place;
+    public var received:Boolean;
+    public def this(place:Place) {
+        this.place = place;
+    }
+}
+

Property changes on: x10.runtime/src-x10/x10/array/GhostNeighborFlag.x10
___________________________________________________________________
Added: svn:mime-type
   + text/plain
Added: svn:eol-style
   + native

Index: x10.runtime/src-x10/x10/array/PeriodicBoundaryConditions.x10
===================================================================
--- x10.runtime/src-x10/x10/array/PeriodicBoundaryConditions.x10	(revision 0)
+++ x10.runtime/src-x10/x10/array/PeriodicBoundaryConditions.x10	(revision 0)
@@ -0,0 +1,35 @@
+/*
+ *  This file is part of the X10 project (http://x10-lang.org).
+ *
+ *  This file is licensed to You under the Eclipse Public License (EPL);
+ *  You may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *      http://www.opensource.org/licenses/eclipse-1.0.php
+ *
+ *  (C) Copyright Australian National University 2010-2011.
+ */
+
+package x10.array;
+
+import x10.compiler.Inline;
+
+/**
+ * Represents periodic boundary conditions, in which elements at each edge of
+ * a region are considered to be neighbours, and indexes that fall
+ * outside the "home" region in any dimension are wrapped around modulo 
+ * the size of the region in that dimension.
+ */
+public final class PeriodicBoundaryConditions {
+    public static def getPeriodicIndex(index : Int, min:Int, max:Int) : Int {
+        val delta = (max-min+1);
+        var actualIndex : Int = index;
+        while (actualIndex < min) actualIndex += delta;
+        while (actualIndex > max) actualIndex -= delta;
+        return actualIndex;
+    }
+
+    public static def wrapPeriodic(pt:Point, r:Region):Point{self.rank==pt.rank} {
+        return Point.make(pt.rank, (i : Int) => getPeriodicIndex(pt(i), r.min(i), r.max(i)));
+    }
+}
+

Property changes on: x10.runtime/src-x10/x10/array/PeriodicBoundaryConditions.x10
___________________________________________________________________
Added: svn:mime-type
   + text/plain
Added: svn:eol-style
   + native

Index: x10.runtime/src-x10/x10/array/PolyRegion.x10
===================================================================
--- x10.runtime/src-x10/x10/array/PolyRegion.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/PolyRegion.x10	(working copy)
@@ -331,4 +331,4 @@
     }
 
 }
-public type PolyRegion(rank:Int) = PolyRegion{self.rank==rank};
\ No newline at end of file
+public type PolyRegion(rank:Int) = PolyRegion{self.rank==rank};
Index: x10.runtime/src-x10/x10/array/Region.x10
===================================================================
--- x10.runtime/src-x10/x10/array/Region.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/Region.x10	(working copy)
@@ -382,7 +382,23 @@
    
     abstract public def eliminate(axis: int): Region /*(rank-1)*/;
 
+    /**
+     * @return the halo region of this region, which is the bounding box 
+     * for this region expanded in each dimension by <code>ghostWidth</code>
+     */
+    public def getHalo(haloWidth:Int):Region(rank) {
+        if (haloWidth == 0 || this.isEmpty()) return this;
+        val r = boundingBox();
+        val min = new Array[Int](rank);
+        val max = new Array[Int](rank);
+        for (i in 0..(rank-1)) {
+            min(i) = r.min(i) - haloWidth;
+            max(i) = r.max(i) + haloWidth;
+        }
+        return Region.makeRectangular(min, max);
+    }
 
+
     /**
      * Return an iterator for this region. Normally accessed using the
      * syntax
Index: x10.runtime/src-x10/x10/array/UniqueDist.x10
===================================================================
--- x10.runtime/src-x10/x10/array/UniqueDist.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/UniqueDist.x10	(working copy)
@@ -79,22 +79,6 @@
 
     public operator this(i0:int){rank==1}:Place = pg(i0);
 
-    public def offset(pt:Point(rank)):int {
-        if (CompilerFlags.checkBounds() && !(pt(0) >= 0 && pt(0) < pg.numPlaces())) {
-            raiseBoundsError(pt);
-        }
-        if (CompilerFlags.checkPlace() && pt(0) != pg.indexOf(here)) raisePlaceError(pt);
-        return 0;
-    }
-
-    public def offset(i0:int){rank==1}:int {
-        if (CompilerFlags.checkBounds() && !(i0 >= 0 && i0 < numPlaces())) {
-            raiseBoundsError(i0);
-        }
-        if (CompilerFlags.checkPlace() && i0 != pg.indexOf(here)) raisePlaceError(i0);
-        return 0;
-    }
-
     // replicated from superclass to workaround xlC bug with using & itables
     // This code is completely unreachable
     public operator this(i0:int, i1:int){rank==2}:Place {
@@ -113,8 +97,6 @@
        throw new UnsupportedOperationException("operator(i0:int,i1:int,i2:int,i3:int)");
     }
 
-    public def maxOffset():int = 0;
-
     public def restriction(r:Region(rank)):Dist(rank) {
 	return new WrappedDistRegionRestricted(this, r);// as Dist(rank); // TODO: cast should not be needed
     }
Index: x10.runtime/src-x10/x10/array/WrappedDistPlaceRestricted.x10
===================================================================
--- x10.runtime/src-x10/x10/array/WrappedDistPlaceRestricted.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/WrappedDistPlaceRestricted.x10	(working copy)
@@ -65,16 +65,6 @@
     // replicated from superclass to workaround xlC bug with using & itables
     public operator this(i0:int, i1:int, i2:int, i3:int){rank==4}:Place = this(Point.make(i0,i1,i2,i3));
 
-    public def offset(pt:Point(rank)):int {
-        if (here == filter) {
-            return base.offset(pt);
-       } else {
-            throw new ArrayIndexOutOfBoundsException("point " + pt + " not contained in distribution");
-        }
-    }
-
-    public def maxOffset():int = base.maxOffset();
-
     public def restriction(r:Region(rank)):Dist(rank) {
         return new WrappedDistRegionRestricted(this, r); 
     }
@@ -93,4 +83,4 @@
 	return this.base.equals(that.base) && this.filter.equals(that.filter);
     }
 }
-public type WrappedDistPlaceRestricted(r:Int)=WrappedDistPlaceRestricted{self.rank==r};
\ No newline at end of file
+public type WrappedDistPlaceRestricted(r:Int)=WrappedDistPlaceRestricted{self.rank==r};
Index: x10.runtime/src-x10/x10/array/WrappedDistRegionRestricted.x10
===================================================================
--- x10.runtime/src-x10/x10/array/WrappedDistRegionRestricted.x10	(revision 23788)
+++ x10.runtime/src-x10/x10/array/WrappedDistRegionRestricted.x10	(working copy)
@@ -62,16 +62,6 @@
     // replicated from superclass to workaround xlC bug with using & itables
     public operator this(i0:int, i1:int, i2:int, i3:int){rank==4}:Place = this(Point.make(i0,i1,i2,i3));
 
-    public def offset(pt:Point(rank)):int {
-        if (filter.contains(pt)) {
-            return base.offset(pt);
-        } else {
-            throw new ArrayIndexOutOfBoundsException("point " + pt + " not contained in distribution");
-        }
-    }
-
-    public def maxOffset():int = base.maxOffset();
-
     public def restriction(r:Region(rank)):Dist(rank) {
         return new WrappedDistRegionRestricted(base, filter.intersection(r)); 
     }
@@ -86,4 +76,4 @@
 	return this.base.equals(that.base) && this.filter.equals(that.filter);
     }
 }
-public type WrappedDistRegionRestricted(r:Int) = WrappedDistRegionRestricted{self.rank==r};
\ No newline at end of file
+public type WrappedDistRegionRestricted(r:Int) = WrappedDistRegionRestricted{self.rank==r};
